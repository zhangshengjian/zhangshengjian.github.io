<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>坚持到放弃</title>
  
  <subtitle>make one more step.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangshengjian.github.io/"/>
  <updated>2019-07-13T14:30:13.670Z</updated>
  <id>https://zhangshengjian.github.io/</id>
  
  <author>
    <name>张 胜 健 的 博 客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ 安装配置</title>
    <link href="https://zhangshengjian.github.io/2019/07/13/RabbitMQ-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhangshengjian.github.io/2019/07/13/RabbitMQ-安装配置/</id>
    <published>2019-07-13T13:55:00.000Z</published>
    <updated>2019-07-13T14:30:13.670Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac-安装-RabbitMQ"><a href="#Mac-安装-RabbitMQ" class="headerlink" title="Mac 安装 RabbitMQ"></a>Mac 安装 RabbitMQ</h4><p>终端运行如下命令即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install rabbitmq</span><br></pre></td></tr></table></figure></p><h4 id="Mac-启动-RabbitMQ"><a href="#Mac-启动-RabbitMQ" class="headerlink" title="Mac 启动 RabbitMQ"></a>Mac 启动 RabbitMQ</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入到 RabbitMQ 目录</span><br><span class="line"></span><br><span class="line">cd /usr/local/Cellar/rabbitmq/3.7.16</span><br><span class="line"></span><br><span class="line"># 启动 RabbitMQ</span><br><span class="line">sbin/rabbitmq-server</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-24.png" alt="图一"></p><p>访问地址查看是否安装成功 <a href="http://localhost:15672/，" target="_blank" rel="noopener">http://localhost:15672/，</a> 登录用户名 guest 密码 guest<br><img src="/images/pasted-25.png" alt="图二"><br><img src="/images/pasted-26.png" alt="图三"></p><h4 id="创建帐号并设置其角色为管理员"><a href="#创建帐号并设置其角色为管理员" class="headerlink" title="创建帐号并设置其角色为管理员"></a>创建帐号并设置其角色为管理员</h4><p><img src="/images/pasted-27.png" alt="图四"></p><h4 id="创建一个新的虚拟-host-为：-mall"><a href="#创建一个新的虚拟-host-为：-mall" class="headerlink" title="创建一个新的虚拟 host 为：/mall"></a>创建一个新的虚拟 host 为：/mall</h4><p><img src="/images/pasted-28.png" alt="图五"></p><h4 id="点击-mall-用户进入用户配置页面"><a href="#点击-mall-用户进入用户配置页面" class="headerlink" title="点击 mall 用户进入用户配置页面"></a>点击 mall 用户进入用户配置页面</h4><p><img src="/images/pasted-29.png" alt="图六"></p><h4 id="给-mall-用户配置该虚拟-host-的权限"><a href="#给-mall-用户配置该虚拟-host-的权限" class="headerlink" title="给 mall 用户配置该虚拟 host 的权限"></a>给 mall 用户配置该虚拟 host 的权限</h4><p><img src="/images/pasted-30.png" alt="图七"></p><p>至此，RabbitMQ 的安装和配置完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mac-安装-RabbitMQ&quot;&gt;&lt;a href=&quot;#Mac-安装-RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;Mac 安装 RabbitMQ&quot;&gt;&lt;/a&gt;Mac 安装 RabbitMQ&lt;/h4&gt;&lt;p&gt;终端运行如下命令即可&lt;br&gt;&lt;fig
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://zhangshengjian.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://zhangshengjian.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis 入门</title>
    <link href="https://zhangshengjian.github.io/2019/07/12/Redis-%E5%85%A5%E9%97%A8/"/>
    <id>https://zhangshengjian.github.io/2019/07/12/Redis-入门/</id>
    <published>2019-07-12T07:59:00.000Z</published>
    <updated>2019-07-12T09:29:31.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Redis 官网 <a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a></p></blockquote><h4 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h4><ul><li>下载 Redis，下载地址：<a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></li><li><p>解压 Redis 安装文件到 /usr/local 目录下，并执行如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 编译测试</span><br><span class="line">sudo make test</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"># 启动 redis 服务器</span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure></li><li><p>至此安装完毕<br><img src="/images/pasted-22.png" alt="图一"></p></li></ul><h4 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h4><ul><li><p>在 /usr/local 目录创建 bin, etc 两个文件夹，在 redis 目录下创建 db 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/bin</span><br><span class="line">sudo mkdir /usr/local/etc</span><br><span class="line">sudo mkdir /usr/local/redis-xxx/db</span><br></pre></td></tr></table></figure></li><li><p>将 /usr/local/redis-x.x.x/src 目录下的 mkreleasehdr.sh, redis-benchmark, redis-check-rdb, redis-cli, redis server 拷贝至 /usr/local/bin 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/local/redis-x.x.x/src/mkreleasehdr.sh /usr/local/bin</span><br><span class="line">sudo cp /usr/local/redis-x.x.x/src/redis-benchmark /usr/local/bin</span><br><span class="line">sudo cp /usr/local/redis-x.x.x/src/redis-check-rdb /usr/local/bin</span><br><span class="line">sudo cp /usr/local/redis-x.x.x/src/redis-cli /usr/local/bin</span><br><span class="line">sudo cp /usr/local/redis-x.x.x/src/redis-server /usr/local/bin</span><br></pre></td></tr></table></figure></li><li><p>将 redis.conf 拷贝至目录 etc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/local/redis-x.x.x/redis.conf /usr/local/etc</span><br></pre></td></tr></table></figure></li><li><p>修改 redis.conf<br>进入 redis/etc 目录，修改 redis.conf，如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 修改为守护模式</span><br><span class="line"> </span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 设置进程锁文件</span><br><span class="line"> </span><br><span class="line">pidfile /usr/local/redis/redis.pid</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line"> </span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 客户端超时时间</span><br><span class="line"></span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line"># 日志级别</span><br><span class="line"> </span><br><span class="line">loglevel debug</span><br><span class="line"></span><br><span class="line"># 日志文件位置</span><br><span class="line"> </span><br><span class="line">logfile /usr/local/redis/log-redis.log</span><br><span class="line"></span><br><span class="line"># 设置数据库的数量，默认数据库为0，可以使用 SELECT &lt;dbid&gt; 命令在连接上指定数据库id</span><br><span class="line"> </span><br><span class="line">databases 8</span><br><span class="line"></span><br><span class="line"># 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># Redis 默认配置文件中提供了三个条件：</span><br><span class="line"> </span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该#选项，但会导致数据库文件变的巨大</span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 指定本地数据库文件名</span><br><span class="line"> </span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"> </span><br><span class="line"># 指定本地数据库路径</span><br><span class="line"> </span><br><span class="line">dir /usr/local/redis/db/</span><br><span class="line"></span><br><span class="line"># 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span><br><span class="line"># 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中</span><br><span class="line"> </span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># 指定更新日志条件，共有3个可选值：</span><br><span class="line"># no：表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line"># always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）</span><br><span class="line"># everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line"> </span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /usr/local/redis-x.x.x/log-redis.log</span><br></pre></td></tr></table></figure></li><li><p>关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure></li></ul><h4 id="Redis-缓存清理"><a href="#Redis-缓存清理" class="headerlink" title="Redis 缓存清理"></a>Redis 缓存清理</h4><p>准备工作：启动 redis 后才可以执行后面内容（sudo redis-server /usr/local/etc/redis.conf）</p><ol><li><p>访问 redis 根目录 cd /usr/local/redis-x.x.x</p></li><li><p>登录 redis：redis-cli -h 127.0.0.1 -p 6379</p></li><li><p>查看所有 key 值：keys *</p></li><li><p>删除指定索引的值：del key</p></li><li><p>清空整个 Redis 服务器的数据：flushall </p></li><li><p>清空当前库中的所有 key：flushdb </p></li></ol><h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h4><p><a href="https://blog.csdn.net/qq_38728790/article/details/82703308" target="_blank" rel="noopener">https://blog.csdn.net/qq_38728790/article/details/82703308</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Redis 官网 &lt;a href=&quot;http://redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://redis.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Mac-安装-Red
      
    
    </summary>
    
      <category term="Redis" scheme="https://zhangshengjian.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://zhangshengjian.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 使用问题记录</title>
    <link href="https://zhangshengjian.github.io/2019/07/12/MySQL-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://zhangshengjian.github.io/2019/07/12/MySQL-使用问题记录/</id>
    <published>2019-07-12T05:17:00.000Z</published>
    <updated>2019-07-12T05:21:46.323Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac-启动-mysql-服务失败"><a href="#Mac-启动-mysql-服务失败" class="headerlink" title="Mac 启动 mysql 服务失败"></a>Mac 启动 mysql 服务失败</h4><p>Warning:The /usr/local/mysql/data directory is not owned by the ‘mysql’ or ‘_mysql’</p><p>解决方法：<br>这应该是某种情况下导致 /usr/local/mysql/data 的宿主发生了改变，只需要在终端运行如下命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R mysql /usr/local/mysql/data</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mac-启动-mysql-服务失败&quot;&gt;&lt;a href=&quot;#Mac-启动-mysql-服务失败&quot; class=&quot;headerlink&quot; title=&quot;Mac 启动 mysql 服务失败&quot;&gt;&lt;/a&gt;Mac 启动 mysql 服务失败&lt;/h4&gt;&lt;p&gt;Warning:Th
      
    
    </summary>
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 常用命令</title>
    <link href="https://zhangshengjian.github.io/2019/07/09/PostgreSQL-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhangshengjian.github.io/2019/07/09/PostgreSQL-使用笔记/</id>
    <published>2019-07-09T09:14:00.000Z</published>
    <updated>2019-07-12T03:01:58.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PostgreSQL 常用命令</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>/Library/PostgreSQL/11/scripts/runpsql.sh; exit</td><td>启动 PostgreSQL，终端执行命令如下（或直接单击 SQL Shell(psql)）</td></tr><tr><td>\help &lt;command_name&gt;</td><td>查看命令帮助</td></tr><tr><td>\l</td><td>查看已存在的数据库</td></tr><tr><td>\c &lt;database_name&gt;</td><td>进入数据库</td></tr><tr><td>\d &lt;table_name&gt;</td><td>查看表结构</td></tr><tr><td>drop table &lt;table_name&gt;</td><td>删除表</td></tr><tr><td>create schema &lt;schema_name&gt;</td><td>创建模式</td></tr><tr><td>drop schema &lt;schema_name&gt;</td><td>删除模式（删除一个为空的模式-其中的所有对象已经被删除）</td></tr><tr><td>drop schema &lt;schema_name&gt; cascade</td><td>删除模式（删除一个模式以及其中包含的所有对象）</td></tr><tr><td>\di &lt;table_name&gt;</td><td>查看索引</td></tr><tr><td>drop index &lt;index_name&gt;</td><td>删除索引</td></tr><tr><td>truncate table &lt;table_name&gt;</td><td>清除表数据</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;PostgreSQL 常用命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/Library/Post
      
    
    </summary>
    
      <category term="PostgreSQL" scheme="https://zhangshengjian.github.io/categories/PostgreSQL/"/>
    
    
      <category term="PostgreSQL" scheme="https://zhangshengjian.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Java 程序员面试题</title>
    <link href="https://zhangshengjian.github.io/2019/06/27/Java-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhangshengjian.github.io/2019/06/27/Java-程序员面试题/</id>
    <published>2019-06-27T06:42:50.000Z</published>
    <updated>2019-07-03T13:43:17.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题拓扑图"><a href="#面试题拓扑图" class="headerlink" title="面试题拓扑图"></a>面试题拓扑图</h3><p><img src="/images/pasted-17.png" alt="图一"></p><hr><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h4 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h4><ul><li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><h4 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h4><p><strong>== 解读</strong><br>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同</li><li>引用类型：比较的是引用是否相同</li></ul><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = &quot;string&quot;;</span><br><span class="line">String y = &quot;string&quot;;</span><br><span class="line">String z = new String(&quot;string&quot;);</span><br><span class="line">System.out.println(x == y); // true</span><br><span class="line">System.out.println(x == z); // false</span><br><span class="line">System.out.println(x.equals(y)); // true</span><br><span class="line">System.out.println(x.equals(z)); // true</span><br></pre></td></tr></table></figure></p><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String() 方法则重写，开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p><strong>equals解读</strong><br>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Cat &#123;</span><br><span class="line">    public Cat(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = new Cat(&quot;ZSJ&quot;);</span><br><span class="line">Cat c2 = new Cat(&quot;ZSJ&quot;);</span><br><span class="line">System.out.println(c1.equals(c2)); // false</span><br></pre></td></tr></table></figure></p><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来 equals 本质上就是 ==。</p><p>那么问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;老王&quot;);</span><br><span class="line">String s2 = new String(&quot;老王&quot;);</span><br><span class="line">System.out.println(s1.equals(s2)); // true</span><br></pre></td></tr></table></figure></p><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p><strong>总结</strong>：== 对于基本数据类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以在一般情况下 equals 比较等是值是否相等。</p><h4 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定为 true。<br>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;通话&quot;;</span><br><span class="line">String str2 = &quot;重地&quot;;</span><br><span class="line">System.out.println(String.format(&quot;str1:%d|str2:%d&quot;), str1.hashCode(), str2.hashCode());</span><br><span class="line">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure></p><p>执行的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1: 1179395 | str2: 1179395</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>代码解读：很显然 “通话” 和 “重地” 的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h4 id="final-在-Java-中有什么作用？"><a href="#final-在-Java-中有什么作用？" class="headerlink" title="final 在 Java 中有什么作用？"></a>final 在 Java 中有什么作用？</h4><ul><li>final 修饰的类叫最终类，该类不能被继承</li><li>final 修饰的方法不能被重写</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改</li></ul><h4 id="Java-中的-Math-round-1-5-等于多少？"><a href="#Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="Java 中的 Math.round(-1.5) 等于多少？"></a>Java 中的 Math.round(-1.5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h4 id="String-属于基础的数据类型吗？"><a href="#String-属于基础的数据类型吗？" class="headerlink" title="String 属于基础的数据类型吗？"></a>String 属于基础的数据类型吗？</h4><p>String 不属于基础数据类型，基础数据类型有8种：byte、boolean、char、short、int、float、double、long，而 String 属于对象。</p><h4 id="Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br>StringBuffer 和 StringBuilder 最大区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h4 id="String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str = “i” 与 String str = new String(“i”) 一样吗？"></a>String str = “i” 与 String str = new String(“i”) 一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str = “i” 的方式，Java 虚拟机会将其分配到常量池中；而 String str = new String(“i”) 则会被分配到堆内存中。</p><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或 StringBuffer 的 reverse() 方法。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer.append(&quot;abcdefg&quot;);</span><br><span class="line">System.out.println(stringBuffer.reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder.append(&quot;abcdefg&quot;);</span><br><span class="line">System.out.println(stringBuilder.reverse()); // gfedcba</span><br></pre></td></tr></table></figure></p><h4 id="String-类的常用方法都有哪些？"><a href="#String-类的常用方法都有哪些？" class="headerlink" title="String 类的常用方法都有哪些？"></a>String 类的常用方法都有哪些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字母。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Red &#123;</span><br><span class="line">    public static void sayHi() &#123;</span><br><span class="line">        System.out.println(&quot;hi ~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承但，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><p><img src="/images/pasted-18.png" alt="图二"></p><h4 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h4><ul><li>实现：抽象类但子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>实现数量：类可以实现多个接口；但只能继承一个抽象类。</li><li>访问修饰符：接口中但方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h4 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。<br>按类型来分：字节流和字符流。<br>字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符为单位输入输出数据。</p><h4 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h4><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非阻塞 IO，异步 IO 的操作基于事件和回调机制。</li></ul><h4 id="Files-的常用方法都有哪些？"><a href="#Files-的常用方法都有哪些？" class="headerlink" title="Files 的常用方法都有哪些？"></a>Files 的常用方法都有哪些？</h4><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="Java-容器都有哪些？"><a href="#Java-容器都有哪些？" class="headerlink" title="Java 容器都有哪些？"></a>Java 容器都有哪些？</h4><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><ul><li>Collection</li><li>List<ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li>Set<ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li><li>Map<ul><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h4 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h4><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections.sort(list)。</li></ul><h4 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许重复。<br>三者之间的区别，如下表：</p><p><img src="/images/pasted-20.png" alt="图三"></p><h4 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h4><ul><li>存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h4 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序对遍历，那 TreeMap 是更好对选择。</p><h4 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value) 存储，get(key) 来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;ZSJ&quot;);</span><br><span class="line">list.add(&quot;的博客&quot;);</span><br><span class="line">list.toArray();</span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[] &#123;&quot;ZSJ&quot;, &quot;的博客&quot;&#125;;</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></table></figure></p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><h4 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h4><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll() 和 remove() 有什么区别？"></a>在 Queue 中 poll() 和 remove() 有什么区别？</h4><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue.offer(&quot;string&quot;); // add</span><br><span class="line">System.out.println(queue.poll());</span><br><span class="line">System.out.println(queue.remove());</span><br><span class="line">System.out.println(queue.size());</span><br></pre></td></tr></table></figure></p><h4 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">  String obj = it.next();</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h4><p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p><p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(&quot;x&quot;);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(&quot;y&quot;); // 运行时此行报错</span><br><span class="line">System.out.println(list. size());</span><br></pre></td></tr></table></figure></p><hr><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><ul><li>并行：多个处理器或多核处理器同时处理多个任务。</li><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li></ul><p>如下图：</p><p><img src="/images/pasted-21.png" alt="图四"></p><p>并发 = 两个队列和一台咖啡机。<br>并行 = 两个队列和两台咖啡机。</p><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><h4 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h4><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h4 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h4><p>创建线程有三种方式：</p><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><h4 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h4><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><h4 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h4><p>线程的状态：</p><ul><li>NEW 尚未启动</li><li>RUNNABLE 正在执行中</li><li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li><li>WAITING 永久等待状态</li><li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li><li>TERMINATED 执行完成</li></ul><h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h4><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul><h4 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll()有什么区别？"></a>notify() 和 notifyAll()有什么区别？</h4><p>notifyAll() 会唤醒所有的线程，notify() 之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify() 只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h4 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run() 和 start() 有什么区别？"></a>线程的 run() 和 start() 有什么区别？</h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h4 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h4><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li><p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p></li><li><p>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p></li><li><p>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p></li><li><p>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p></li><li><p>newScheduledThreadPool(int corePoolSize)：和 newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p></li><li><p>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序；</p></li><li><p>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对 ThreadPoolExecutor 的封装。</p></li></ul><h4 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h4><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h4 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><ul><li>execute()：只能执行 Runnable 类型的任务。</li><li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li></ul><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h4 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h4><ul><li>方法一：使用安全类，比如 java.util.concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 Java 示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;获得锁&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;释放锁&quot;);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h4><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h4 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h4><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 java.util.concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><h4 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h4><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h4 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h4><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><h4 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h4><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h4 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><h4 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h4><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h4 id="什么是-Java-序列化？什么情况下需要序列化？"><a href="#什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 Java 序列化？什么情况下需要序列化？"></a>什么是 Java 序列化？什么情况下需要序列化？</h4><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p><p>以下情况需要使用 Java 序列化：</p><ul><li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>想用套接字在网络上传送对象的时候；</li><li>想通过 RMI（远程方法调用）传输对象的时候。</li></ul><h4 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h4><p>动态代理是运行时动态生成代理类。</p><p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java 注解对象获取等。</p><h4 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h4><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><h4 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h4><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p><h4 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h4><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul><h4 id="深拷贝和浅拷贝区别是什么？"><a href="#深拷贝和浅拷贝区别是什么？" class="headerlink" title="深拷贝和浅拷贝区别是什么？"></a>深拷贝和浅拷贝区别是什么？</h4><ul><li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li><li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li></ul><h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><h4 id="JSP-和-servlet-有什么区别？"><a href="#JSP-和-servlet-有什么区别？" class="headerlink" title="JSP 和 servlet 有什么区别？"></a>JSP 和 servlet 有什么区别？</h4><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p><h4 id="JSP-有哪些内置对象？作用分别是什么？"><a href="#JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP 有哪些内置对象？作用分别是什么？"></a>JSP 有哪些内置对象？作用分别是什么？</h4><p>JSP 有 9 大内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web 应用的配置对象；</li><li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h4 id="说一下-JSP-的-4-种作用域？"><a href="#说一下-JSP-的-4-种作用域？" class="headerlink" title="说一下 JSP 的 4 种作用域？"></a>说一下 JSP 的 4 种作用域？</h4><ul><li>page：代表与一个页面相关的对象和属性。</li><li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li><li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li><li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h4 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h4><ul><li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li><li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li><li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li><li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li></ul><h4 id="说一下-session-的工作原理？"><a href="#说一下-session-的工作原理？" class="headerlink" title="说一下 session 的工作原理？"></a>说一下 session 的工作原理？</h4><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p><h4 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h4><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p><h4 id="spring-mvc-和-struts-的区别是什么？"><a href="#spring-mvc-和-struts-的区别是什么？" class="headerlink" title="spring mvc 和 struts 的区别是什么？"></a>spring mvc 和 struts 的区别是什么？</h4><ul><li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li><li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li><li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li><li>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li></ul><h4 id="如何避免-SQL-注入？"><a href="#如何避免-SQL-注入？" class="headerlink" title="如何避免 SQL 注入？"></a>如何避免 SQL 注入？</h4><ul><li>使用预处理 PreparedStatement。</li><li>使用正则表达式过滤掉字符中的特殊字符。</li></ul><h4 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h4><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p><p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p><h4 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h4><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>防御手段：</p><ul><li>验证请求来源地址；</li><li>关键操作添加验证码；</li><li>在请求地址添加 token 并验证。</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h4><ul><li>throw：是真实抛出一个异常。</li><li>throws：是声明可能会抛出一个异常。</li></ul><h4 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h4><ul><li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li><li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li><li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li></ul><h4 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h4><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p><h4 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p><h4 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h4><ul><li>NullPointerException 空指针异常</li><li>ClassNotFoundException 指定类不存在</li><li>NumberFormatException 字符串转换为数字异常</li><li>IndexOutOfBoundsException 数组下标越界异常</li><li>ClassCastException 数据类型转换异常</li><li>FileNotFoundException 文件未找到异常</li><li>NoSuchMethodException 方法不存在异常</li><li>IOException IO 异常</li><li>SocketException Socket 异常</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301：永久重定向。</p><p>302：暂时重定向。</p><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p><h4 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h4><p>forward 是转发 和 redirect 是重定向：</p><ul><li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li><li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li><li>效率：forward 比 redirect 效率高。</li></ul><h4 id="简述-tcp-和-udp-的区别？"><a href="#简述-tcp-和-udp-的区别？" class="headerlink" title="简述 tcp 和 udp 的区别？"></a>简述 tcp 和 udp 的区别？</h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p><p>两者的区别大致如下：</p><ul><li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li><li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li><li>tcp 面向字节流，udp 面向报文；</li><li>tcp 数据传输慢，udp 数据传输快；</li></ul><h4 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p><h4 id="说一下-tcp-粘包是怎么产生的？"><a href="#说一下-tcp-粘包是怎么产生的？" class="headerlink" title="说一下 tcp 粘包是怎么产生的？"></a>说一下 tcp 粘包是怎么产生的？</h4><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p><ul><li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li><li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li></ul><h4 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h4><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：负责建立和管理节点间的链路。</li><li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li><li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li><li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li><li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li><li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li></ul><h4 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h4><ul><li>get 请求会被浏览器主动缓存，而 post 不会。</li><li>get 传递参数有大小限制，而 post 没有。</li><li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li></ul><h4 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h4><p>实现跨域有以下几种方案：</p><ul><li>服务器端运行跨域 设置 CORS 等于 *；</li><li>在单个接口使用注解 @CrossOrigin 运行跨域；</li><li>使用 jsonp 跨域；</li></ul><h4 id="说一下-JSONP-实现原理？"><a href="#说一下-JSONP-实现原理？" class="headerlink" title="说一下 JSONP 实现原理？"></a>说一下 JSONP 实现原理？</h4><p>jsonp：JSON with Padding，它是利用 script 标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="说一下你熟悉的设计模式？"><a href="#说一下你熟悉的设计模式？" class="headerlink" title="说一下你熟悉的设计模式？"></a>说一下你熟悉的设计模式？</h4><ul><li>单例模式：保证被创建一次，节省系统开销。</li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li><li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li><li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li><li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li><li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li></ul><h4 id="简单工厂和抽象工厂有什么区别？"><a href="#简单工厂和抽象工厂有什么区别？" class="headerlink" title="简单工厂和抽象工厂有什么区别？"></a>简单工厂和抽象工厂有什么区别？</h4><ul><li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li><li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li><li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li></ul><h3 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h3><h4 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h4><ul><li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li><li>spring 提供了事务支持，使得事务操作变的更加方便。</li><li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li><li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</li></ul><h4 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h4><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p><h4 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h4><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p><p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p><h4 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h4><ul><li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring dao：Data Access Object 提供了JDBC的抽象层。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li></ul><h4 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h4><ul><li>setter 属性注入</li><li>构造方法注入</li><li>注解方式注入</li></ul><h4 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h4><p>spring 支持 5 种作用域，如下：</p><ul><li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li><li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li><li>Web 环境下的作用域：</li><li>request：每次 http 请求都会创建一个 bean；</li><li>session：同一个 http session 共享一个 bean 实例；</li><li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li></ul><p>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h4 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h4><ul><li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li><li>byName：它根据 bean 的名称注入对象依赖项。</li><li>byType：它根据类型注入对象依赖项。</li><li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li><li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li></ul><h4 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h4><ul><li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li><li>编码方式：提供编码的形式管理和维护事务。</li></ul><h4 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h4><ul><li>spring mvc 先将请求发送给 DispatcherServlet。</li><li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li><li>DispatcherServlet 再把请求提交到对应的 Controller。</li><li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li><li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li><li>视图对象负责渲染返回给客户端。</li></ul><h4 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h4><ul><li>前置控制器 DispatcherServlet。</li><li>映射控制器 HandlerMapping。</li><li>处理器 Controller。</li><li>模型和视图 ModelAndView。</li><li>视图解析器 ViewResolver。</li></ul><h4 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h4><p>将 http 请求映射到相应的类/方法上。</p><h4 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h4><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p><h3 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h3><h4 id="什么是-spring-boot？"><a href="#什么是-spring-boot？" class="headerlink" title="什么是 spring boot？"></a>什么是 spring boot？</h4><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p><h4 id="为什么要用-spring-boot？"><a href="#为什么要用-spring-boot？" class="headerlink" title="为什么要用 spring boot？"></a>为什么要用 spring boot？</h4><ul><li>配置简单</li><li>独立运行</li><li>自动装配</li><li>无代码生成和 xml 配置</li><li>提供应用监控</li><li>易上手</li><li>提升开发效率</li></ul><h4 id="spring-boot-核心配置文件是什么？"><a href="#spring-boot-核心配置文件是什么？" class="headerlink" title="spring boot 核心配置文件是什么？"></a>spring boot 核心配置文件是什么？</h4><p>spring boot 核心的两个配置文件：</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li></ul><h4 id="spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="spring boot 配置文件有哪几种类型？它们有什么区别？"></a>spring boot 配置文件有哪几种类型？它们有什么区别？</h4><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p><p>.properties 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.RabbitMQ.port=5672</span><br></pre></td></tr></table></figure></p><p>.yml 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    RabbitMQ:</span><br><span class="line">        port: 5672</span><br></pre></td></tr></table></figure></p><p>.yml 格式不支持 @PropertySource 注解导入。</p><h4 id="spring-boot-有哪些方式可以实现热部署？"><a href="#spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="spring boot 有哪些方式可以实现热部署？"></a>spring boot 有哪些方式可以实现热部署？</h4><ul><li>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</li><li>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</li></ul><h4 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h4><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p><h4 id="什么是-spring-cloud？"><a href="#什么是-spring-cloud？" class="headerlink" title="什么是 spring cloud？"></a>什么是 spring cloud？</h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p><h4 id="spring-cloud-断路器的作用是什么？"><a href="#spring-cloud-断路器的作用是什么？" class="headerlink" title="spring cloud 断路器的作用是什么？"></a>spring cloud 断路器的作用是什么？</h4><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><h4 id="spring-cloud-的核心组件有哪些？"><a href="#spring-cloud-的核心组件有哪些？" class="headerlink" title="spring cloud 的核心组件有哪些？"></a>spring cloud 的核心组件有哪些？</h4><ul><li>Eureka：服务注册于发现。</li><li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li><li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li><li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li><li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li></ul><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h4 id="为什么要使用-hibernate？"><a href="#为什么要使用-hibernate？" class="headerlink" title="为什么要使用 hibernate？"></a>为什么要使用 hibernate？</h4><ul><li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</li><li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</li><li>可以很方便的进行数据库的移植工作。</li><li>提供了缓存机制，是程序执行更改的高效。</li></ul><h4 id="什么是-ORM-框架？"><a href="#什么是-ORM-框架？" class="headerlink" title="什么是 ORM 框架？"></a>什么是 ORM 框架？</h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p><p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p><h4 id="hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="hibernate 中如何在控制台查看打印的 SQL 语句？"></a>hibernate 中如何在控制台查看打印的 SQL 语句？</h4><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p><h4 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h4><p>三种：hql、原生 SQL、条件查询 Criteria。</p><h4 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h4><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p><h4 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h4><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p><h4 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h4><ul><li>读取并解析配置文件。</li><li>读取并解析映射文件，创建 SessionFactory。</li><li>打开 Session。</li><li>创建事务。</li><li>进行持久化操作。</li><li>提交事务。</li><li>关闭 Session。</li><li>关闭 SessionFactory。</li></ul><h4 id="get-和-load-的区别？"><a href="#get-和-load-的区别？" class="headerlink" title="get()和 load()的区别？"></a>get()和 load()的区别？</h4><ul><li>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</li><li>load()支持延迟加载；get() 不支持延迟加载。</li></ul><h4 id="说一下-hibernate-的缓存机制？"><a href="#说一下-hibernate-的缓存机制？" class="headerlink" title="说一下 hibernate 的缓存机制？"></a>说一下 hibernate 的缓存机制？</h4><p>hibernate 常用的缓存有一级缓存和二级缓存：</p><p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p><p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p><h4 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h4><ul><li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li><li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</li><li>游离状态：Session 关闭之后对象就是游离状态。</li></ul><h4 id="在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h4><ul><li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li><li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li></ul><h4 id="hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="hibernate 实体类必须要有无参构造函数吗？为什么？"></a>hibernate 实体类必须要有无参构造函数吗？为什么？</h4><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="MyBatis-中-和-的区别是什么？"><a href="#MyBatis-中-和-的区别是什么？" class="headerlink" title="MyBatis 中 #{} 和 ${} 的区别是什么？"></a>MyBatis 中 #{} 和 ${} 的区别是什么？</h4><p>#{} 是预编译处理，${} 是字符替换。 在使用 #{} 时，MyBatis 会将 SQL 中的 #{} 替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><h4 id="MyBatis-有几种分页方式？"><a href="#MyBatis-有几种分页方式？" class="headerlink" title="MyBatis 有几种分页方式？"></a>MyBatis 有几种分页方式？</h4><p>分页方式：逻辑分页和物理分页。</p><p><strong>逻辑分页：</strong> 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p><p><strong>物理分页：</strong> 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p><h4 id="RowBounds-是一次性查询全部结果吗？为什么？"><a href="#RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="RowBounds 是一次性查询全部结果吗？为什么？"></a>RowBounds 是一次性查询全部结果吗？为什么？</h4><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next() 的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next() 的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>Fetch Size 官方相关文档：<a href="http://t" target="_blank" rel="noopener">http://t</a>. cn/EfSE2g3</p><h4 id="MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="MyBatis 逻辑分页和物理分页的区别是什么？"></a>MyBatis 逻辑分页和物理分页的区别是什么？</h4><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。<br>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><h4 id="MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a.getB().getName()，这个时候发现 a.getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a.setB(b)，而这时候再调用 a.getB().getName() 就有值了，这就是延迟加载的基本原理。</p><h4 id="说一下-MyBatis-的一级缓存和二级缓存？"><a href="#说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="说一下 MyBatis 的一级缓存和二级缓存？"></a>说一下 MyBatis 的一级缓存和二级缓存？</h4><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。<br>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h4 id="MyBatis-和-hibernate-的区别有哪些？"><a href="#MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="MyBatis 和 hibernate 的区别有哪些？"></a>MyBatis 和 hibernate 的区别有哪些？</h4><p>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。<br>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。<br>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。<br>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p><h4 id="MyBatis-有哪些执行器（Executor）？"><a href="#MyBatis-有哪些执行器（Executor）？" class="headerlink" title="MyBatis 有哪些执行器（Executor）？"></a>MyBatis 有哪些执行器（Executor）？</h4><p>MyBatis 有三种基本的 Executor 执行器：</p><ul><li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li><li>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li><li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li></ul><h4 id="MyBatis-分页插件的实现原理是什么？"><a href="#MyBatis-分页插件的实现原理是什么？" class="headerlink" title="MyBatis 分页插件的实现原理是什么？"></a>MyBatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><h4 id="MyBatis-如何编写一个自定义插件？"><a href="#MyBatis-如何编写一个自定义插件？" class="headerlink" title="MyBatis 如何编写一个自定义插件？"></a>MyBatis 如何编写一个自定义插件？</h4><p><strong>自定义插件实现原理</strong></p><p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li><li>ParameterHandler：拦截参数的处理；</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p><strong>自定义插件实现关键</strong></p><p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;   </span><br><span class="line">   Object intercept(Invocation invocation) throws Throwable;       </span><br><span class="line">   Object plugin(Object target);    </span><br><span class="line">   void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li><li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</li><li>intercept 方法就是要进行拦截的时候要执行的方法。</li></ul><p><strong>自定义插件实现示例</strong></p><p>官方插件实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line">public class TestInterceptor implements Interceptor &#123;</span><br><span class="line">   public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">     Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">     Method method = invocation.getMethod(); //代理方法</span><br><span class="line">     Object[] args = invocation.getArgs(); //方法参数</span><br><span class="line">     // do something . . . . . .  方法拦截前执行代码块</span><br><span class="line">     Object result = invocation.proceed();</span><br><span class="line">     // do something . . . . . . . 方法拦截后执行代码块</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line">   public Object plugin(Object target) &#123;</span><br><span class="line">     return Plugin. wrap(target, this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ-的使用场景有哪些？"><a href="#RabbitMQ-的使用场景有哪些？" class="headerlink" title="RabbitMQ 的使用场景有哪些？"></a>RabbitMQ 的使用场景有哪些？</h4><ul><li>抢购活动，削峰填谷，防止系统崩塌。</li><li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li><li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li></ul><h4 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h4><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h4 id="RabbitMQ-有哪些重要的组件？"><a href="#RabbitMQ-有哪些重要的组件？" class="headerlink" title="RabbitMQ 有哪些重要的组件？"></a>RabbitMQ 有哪些重要的组件？</h4><ul><li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h4 id="RabbitMQ-中-vhost-的作用是什么？"><a href="#RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="RabbitMQ 中 vhost 的作用是什么？"></a>RabbitMQ 中 vhost 的作用是什么？</h4><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的 RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h4 id="RabbitMQ-的消息是怎么发送的？"><a href="#RabbitMQ-的消息是怎么发送的？" class="headerlink" title="RabbitMQ 的消息是怎么发送的？"></a>RabbitMQ 的消息是怎么发送的？</h4><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p><h4 id="RabbitMQ-怎么保证消息的稳定性？"><a href="#RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="RabbitMQ 怎么保证消息的稳定性？"></a>RabbitMQ 怎么保证消息的稳定性？</h4><ul><li>提供了事务的功能。</li><li>通过将 channel 设置为 confirm（确认）模式。</li></ul><h4 id="RabbitMQ-怎么避免消息丢失？"><a href="#RabbitMQ-怎么避免消息丢失？" class="headerlink" title="RabbitMQ 怎么避免消息丢失？"></a>RabbitMQ 怎么避免消息丢失？</h4><ul><li>把消息持久化磁盘，保证服务器重启消息不丢失。</li><li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li></ul><h4 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h4><ul><li>声明队列必须设置持久化 durable 设置为 true.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达持久化队列。<br>以上四个条件都满足才能保证消息持久化成功。</li></ul><h4 id="RabbitMQ-持久化有什么缺点？"><a href="#RabbitMQ-持久化有什么缺点？" class="headerlink" title="RabbitMQ 持久化有什么缺点？"></a>RabbitMQ 持久化有什么缺点？</h4><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h4 id="RabbitMQ-有几种广播类型？"><a href="#RabbitMQ-有几种广播类型？" class="headerlink" title="RabbitMQ 有几种广播类型？"></a>RabbitMQ 有几种广播类型？</h4><p>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>headers：与 direct 类似，只是性能很差，此类型几乎用不到。<br>fanout：分发模式，把消费分发给所有订阅者。<br>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p><h4 id="RabbitMQ-怎么实现延迟消息队列？"><a href="#RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="RabbitMQ 怎么实现延迟消息队列？"></a>RabbitMQ 怎么实现延迟消息队列？</h4><p>延迟队列的实现有两种方式：</p><p>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；<br>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p><h4 id="RabbitMQ-集群有什么用？"><a href="#RabbitMQ-集群有什么用？" class="headerlink" title="RabbitMQ 集群有什么用？"></a>RabbitMQ 集群有什么用？</h4><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li><li>高容量：集群可以承载更多的消息量。</li></ul><h4 id="RabbitMQ-节点的类型有哪些？"><a href="#RabbitMQ-节点的类型有哪些？" class="headerlink" title="RabbitMQ 节点的类型有哪些？"></a>RabbitMQ 节点的类型有哪些？</h4><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h4 id="RabbitMQ-集群搭建需要注意哪些问题？"><a href="#RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="RabbitMQ 集群搭建需要注意哪些问题？"></a>RabbitMQ 集群搭建需要注意哪些问题？</h4><ul><li>各节点之间使用“–link”连接，此属性不能忽略。</li><li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中必须包含一个磁盘节点。</li></ul><h4 id="RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h4><p>不是，原因有以下两个：</p><ul><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ul><h4 id="RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点<br>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</li></ul><h4 id="RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="RabbitMQ 对集群节点停止顺序有要求吗？"></a>RabbitMQ 对集群节点停止顺序有要求吗？</h4><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h4><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h4 id="kafka-有几种数据保留的策略？"><a href="#kafka-有几种数据保留的策略？" class="headerlink" title="kafka 有几种数据保留的策略？"></a>kafka 有几种数据保留的策略？</h4><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h4 id="kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h4><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h4 id="什么情况会导致-kafka-运行变慢？"><a href="#什么情况会导致-kafka-运行变慢？" class="headerlink" title="什么情况会导致 kafka 运行变慢？"></a>什么情况会导致 kafka 运行变慢？</h4><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h4 id="使用-kafka-集群需要注意什么？"><a href="#使用-kafka-集群需要注意什么？" class="headerlink" title="使用 kafka 集群需要注意什么？"></a>使用 kafka 集群需要注意什么？</h4><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li></ul><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h4 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h4 id="zookeeper-都有哪些功能？"><a href="#zookeeper-都有哪些功能？" class="headerlink" title="zookeeper 都有哪些功能？"></a>zookeeper 都有哪些功能？</h4><ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper 可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li></ul><h4 id="zookeeper-有几种部署模式？"><a href="#zookeeper-有几种部署模式？" class="headerlink" title="zookeeper 有几种部署模式？"></a>zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul><h4 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h4 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h4 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h4 id="说一下-zookeeper-的通知机制？"><a href="#说一下-zookeeper-的通知机制？" class="headerlink" title="说一下 zookeeper 的通知机制？"></a>说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h4><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h4 id="一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h4><ul><li>表类型如果是 MyISAM，那 id 就是 8。</li><li>表类型如果是 InnoDB，那 id 就是 6。<br>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</li></ul><h4 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h4 id="说一下-ACID-是什么？"><a href="#说一下-ACID-是什么？" class="headerlink" title="说一下 ACID 是什么？"></a>说一下 ACID 是什么？</h4><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h4><ul><li><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p></li><li><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p></li></ul><h4 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h4><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul><h4 id="MySQL-的内连接、左连接、右连接有什么区别？"><a href="#MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 的内连接、左连接、右连接有什么区别？"></a>MySQL 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h4 id="MySQL-索引是怎么实现的？"><a href="#MySQL-索引是怎么实现的？" class="headerlink" title="MySQL 索引是怎么实现的？"></a>MySQL 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h4 id="怎么验证-MySQL-的索引是否满足需求？"><a href="#怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="怎么验证 MySQL 的索引是否满足需求？"></a>怎么验证 MySQL 的索引是否满足需求？</h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type=1。</p><h4 id="说一下数据库的事务隔离？"><a href="#说一下数据库的事务隔离？" class="headerlink" title="说一下数据库的事务隔离？"></a>说一下数据库的事务隔离？</h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p><p>transaction-isolation = REPEATABLE-READ</p><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><ul><li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。<br><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li></ul><p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p><p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4 id="说一下-MySQL-常用的引擎？"><a href="#说一下-MySQL-常用的引擎？" class="headerlink" title="说一下 MySQL 常用的引擎？"></a>说一下 MySQL 常用的引擎？</h4><ul><li><p>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p></li><li><p>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p></li></ul><h4 id="说一下-MySQL-的行锁和表锁？"><a href="#说一下-MySQL-的行锁和表锁？" class="headerlink" title="说一下 MySQL 的行锁和表锁？"></a>说一下 MySQL 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li></ul><h4 id="说一下乐观锁和悲观锁？"><a href="#说一下乐观锁和悲观锁？" class="headerlink" title="说一下乐观锁和悲观锁？"></a>说一下乐观锁和悲观锁？</h4><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。<br>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</li></ul><h4 id="MySQL-问题排查都有哪些手段？"><a href="#MySQL-问题排查都有哪些手段？" class="headerlink" title="MySQL 问题排查都有哪些手段？"></a>MySQL 问题排查都有哪些手段？</h4><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li>使用 explain 命令查询 SQL 语句执行计划。</li><li>开启慢查询日志，查看慢查询的 SQL。</li></ul><h4 id="如何做-MySQL-的性能优化？"><a href="#如何做-MySQL-的性能优化？" class="headerlink" title="如何做 MySQL 的性能优化？"></a>如何做 MySQL 的性能优化？</h4><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li>垂直分割分表。</li><li>选择正确的存储引擎。</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis-是什么？都有哪些使用场景？"><a href="#Redis-是什么？都有哪些使用场景？" class="headerlink" title="Redis 是什么？都有哪些使用场景？"></a>Redis 是什么？都有哪些使用场景？</h4><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p><p>Redis 使用场景：</p><ul><li>记录帖子点赞数、点击数、评论数；</li><li>缓存近期热帖；</li><li>缓存文章详情信息；</li><li>记录用户会话信息。</li></ul><h4 id="Redis-有哪些功能？"><a href="#Redis-有哪些功能？" class="headerlink" title="Redis 有哪些功能？"></a>Redis 有哪些功能？</h4><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h4 id="Redis-和-memcache-有什么区别？"><a href="#Redis-和-memcache-有什么区别？" class="headerlink" title="Redis 和 memcache 有什么区别？"></a>Redis 和 memcache 有什么区别？</h4><ul><li>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</li><li>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</li></ul><h4 id="Redis-为什么是单线程的？"><a href="#Redis-为什么是单线程的？" class="headerlink" title="Redis 为什么是单线程的？"></a>Redis 为什么是单线程的？</h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><h4 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="Redis-支持的数据类型有哪些？"><a href="#Redis-支持的数据类型有哪些？" class="headerlink" title="Redis 支持的数据类型有哪些？"></a>Redis 支持的数据类型有哪些？</h4><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p><h4 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h4><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p><h4 id="jedis-和-Redisson-有哪些区别？"><a href="#jedis-和-Redisson-有哪些区别？" class="headerlink" title="jedis 和 Redisson 有哪些区别？"></a>jedis 和 Redisson 有哪些区别？</h4><ul><li>jedis：提供了比较全面的 Redis 命令的支持。</li><li>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</li></ul><h4 id="怎么保证缓存和数据库数据的一致性？"><a href="#怎么保证缓存和数据库数据的一致性？" class="headerlink" title="怎么保证缓存和数据库数据的一致性？"></a>怎么保证缓存和数据库数据的一致性？</h4><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h4 id="Redis-持久化有几种方式？"><a href="#Redis-持久化有几种方式？" class="headerlink" title="Redis 持久化有几种方式？"></a>Redis 持久化有几种方式？</h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p><ul><li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li></ul><h4 id="Redis-怎么实现分布式锁？"><a href="#Redis-怎么实现分布式锁？" class="headerlink" title="Redis 怎么实现分布式锁？"></a>Redis 怎么实现分布式锁？</h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h4 id="Redis-分布式锁有什么缺陷？"><a href="#Redis-分布式锁有什么缺陷？" class="headerlink" title="Redis 分布式锁有什么缺陷？"></a>Redis 分布式锁有什么缺陷？</h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h4 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h4><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p><h4 id="Redis-淘汰策略有哪些？"><a href="#Redis-淘汰策略有哪些？" class="headerlink" title="Redis 淘汰策略有哪些？"></a>Redis 淘汰策略有哪些？</h4><ul><li><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p></li><li><p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p></li><li><p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p></li><li><p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p></li><li><p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p></li><li><p>no-enviction（驱逐）：禁止驱逐数据。</p></li></ul><h4 id="Redis-常见的性能问题有哪些？该如何解决？"><a href="#Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="Redis 常见的性能问题有哪些？该如何解决？"></a>Redis 常见的性能问题有哪些？该如何解决？</h4><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="说一下-JVM-的主要组成部分？及其作用？"><a href="#说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="说一下 JVM 的主要组成部分？及其作用？"></a>说一下 JVM 的主要组成部分？及其作用？</h4><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）<br><em>组件的作用：</em> 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li></ul><h4 id="说一下-JVM-运行时数据区？"><a href="#说一下-JVM-运行时数据区？" class="headerlink" title="说一下 JVM 运行时数据区？"></a>说一下 JVM 运行时数据区？</h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p></li><li><p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p></li><li><p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p></li><li><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p></li><li><p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p></li></ul><h4 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h4><ul><li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li><li>共享性：堆是线程共享的，栈是线程私有的。</li><li>空间大小：堆大小远远大于栈。</li></ul><h4 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。</p><p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</li></ul><h4 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h4><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h4 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h4 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h4><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h4 id="说一下-JVM-有哪些垃圾回收算法？"><a href="#说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="说一下 JVM 有哪些垃圾回收算法？"></a>说一下 JVM 有哪些垃圾回收算法？</h4><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h4 id="说一下-JVM-有哪些垃圾回收器？"><a href="#说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="说一下 JVM 有哪些垃圾回收器？"></a>说一下 JVM 有哪些垃圾回收器？</h4><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li><li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul><h4 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h4 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li></ul><h4 id="简述分代垃圾回收器是怎么工作的？"><a href="#简述分代垃圾回收器是怎么工作的？" class="headerlink" title="简述分代垃圾回收器是怎么工作的？"></a>简述分代垃圾回收器是怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li></ul><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h4 id="说一下-JVM-调优的工具？"><a href="#说一下-JVM-调优的工具？" class="headerlink" title="说一下 JVM 调优的工具？"></a>说一下 JVM 调优的工具？</h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h4 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h4><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面试题拓扑图&quot;&gt;&lt;a href=&quot;#面试题拓扑图&quot; class=&quot;headerlink&quot; title=&quot;面试题拓扑图&quot;&gt;&lt;/a&gt;面试题拓扑图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-17.png&quot; alt=&quot;图一&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h
      
    
    </summary>
    
      <category term="Interview" scheme="https://zhangshengjian.github.io/categories/Interview/"/>
    
    
      <category term="Java" scheme="https://zhangshengjian.github.io/tags/Java/"/>
    
      <category term="Interview" scheme="https://zhangshengjian.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>java.lang.Void</title>
    <link href="https://zhangshengjian.github.io/2019/06/27/java-lang-Void/"/>
    <id>https://zhangshengjian.github.io/2019/06/27/java-lang-Void/</id>
    <published>2019-06-27T01:22:06.000Z</published>
    <updated>2019-06-27T01:56:12.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 不是函数，是方法的修饰符，void 的意思是该方法没有任何返回值，意思就是方法只会运行方法中的语句，但是不会返回任何东西。</p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The &#123;@code Void&#125; class is an uninstantiable placeholder class to hold a</span><br><span class="line"> * reference to the &#123;@code Class&#125; object representing the Java keyword</span><br><span class="line"> * void.</span><br><span class="line"> * Void 类是一个不可实例化的占位符类，它持有对标识 Java 关键字 void 的 Class 对象的引用。</span><br><span class="line"> *</span><br><span class="line"> * @author  unascribed</span><br><span class="line"> * @since   JDK1.1</span><br><span class="line"> */</span><br><span class="line">public final</span><br><span class="line">class Void &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The &#123;@code Class&#125; object representing the pseudo-type corresponding to</span><br><span class="line">     * the keyword &#123;@code void&#125;.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(&quot;void&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The Void class cannot be instantiated.</span><br><span class="line">     */</span><br><span class="line">    private Void() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过源码可以看出 java.lang.Void 是一种类型，Void 不可以继承与实例化。</p><p>Void 作为函数的返回结果表示函数返回 null（除了 null 不能返回其它类型）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Void function(int a, int b) &#123;</span><br><span class="line">    // do something</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型出现前，Void 一般用于反射中。例如，下面代码打印返回类型为 void 的方法名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void VoidTest &#123;</span><br><span class="line">    public void print(String v) &#123;&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Method method : VoidTest.class.getMethods()) &#123;</span><br><span class="line">            if (method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">                System.out.println(method.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型出现后，某些场景会用到 Void 类型。例如 Future<t> 用来保存结果。Future 的 get 方法会返回结果（类型为 T。<br>但如果操作并没有返回值，这种情况下就可以用 Future<void> 表示。当调用 get 后结果计算完毕则返回后将会返回 null。<br>另外 Void 也用于无值的 Map 中，例如 Map&lt;T, Void&gt; 这样 map 将具有 Set<t> 一样的功能。</t></void></t></p><p>因此当使用范型时函数不需要返回结果或对象不需要值的时候可以使用 java.lang.Void 类型表示。（Void 类可能本身作用就是不起任何作用，但是本身只是一个占位符类。即 Void 类本身只是一个占位符类，不能被实例化，多用于泛型中作占位符使用）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;void&quot;&gt;&lt;a href=&quot;#void&quot; class=&quot;headerlink&quot; title=&quot;void&quot;&gt;&lt;/a&gt;void&lt;/h3&gt;&lt;p&gt;void 不是函数，是方法的修饰符，void 的意思是该方法没有任何返回值，意思就是方法只会运行方法中的语句，但是不会返回任
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangshengjian.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zhangshengjian.github.io/tags/Java/"/>
    
      <category term="Void" scheme="https://zhangshengjian.github.io/tags/Void/"/>
    
      <category term="void" scheme="https://zhangshengjian.github.io/tags/void/"/>
    
  </entry>
  
  <entry>
    <title>String,StringBuffer,StringBuilder 区别、底层数据结构、如何实现</title>
    <link href="https://zhangshengjian.github.io/2019/06/24/String-StringBuffer-StringBuilder-%E5%8C%BA%E5%88%AB%E3%80%81%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangshengjian.github.io/2019/06/24/String-StringBuffer-StringBuilder-区别、底层数据结构、如何实现/</id>
    <published>2019-06-24T06:30:00.000Z</published>
    <updated>2019-06-25T07:53:03.035Z</updated>
    
    <content type="html"><![CDATA[<p><strong>区别</strong><br>三者主要区别于两方面，即运行速度和线程安全。<br>运行速度：StringBuilder &gt; StringBuffer &gt; String<br>线程安全：StringBuffer 线程安全；StringBuilder 线程不安全</p><p>String 之所以慢，是因为 Java 对 String 对象进行操作实际上是一个不断创建新对对象并且将旧对对象回收的一个过程，所以执行速度很慢，而 StringBuffer 和 StringBuilder 的对象是变量，对变量进行操作就是直接对该对象进行更改，而不需要进行创建和回收的操作，所以速度要比 String 快很多。</p><p><strong>底层数据结构以及实现原理</strong><br><strong>String 类</strong>不可变，内部维护的 char[] 数组长度不可变，为 final 修饰，而 String 类也是 final 修饰，不存在扩容。字符串拼接，截取都会生成一个新的对象。频繁操作字符串效率低下，因为每次都会生成新的对象。</p><p><strong>StringBuilder 类</strong>内部维护可变长度 char[]，初始化数组容量为16，存在扩容，其 append 拼接字符串方法内部调用 System 的 native 方法，进行数组的拷贝，不会重新生成新的 StringBuilder 对象。非线程安全的字符串操作类，每次调用 toString 方法重新生成的 String 对象，不会共享 StringBuilder 对象内部的 char[]，会进行一次 char[] 的 copy 操作。</p><p><strong>StringBuffer 类</strong>内部维护可变长度 char[]，基本上与 StringBuilder 一致，但其为线程安全但字符串操作类，大部分方法都采用了 synchronized 关键字修饰，以此来实现在多线程下的字符串安全性，其 toString 方法重新生成的 String 对象，会共享 StringBuffer 对象中的 toStringCache 属性(char[])，但是每次的 StringBuffer 对象修改都会置 null 该属性值。</p><p><strong>适用场景</strong><br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用于多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;br&gt;三者主要区别于两方面，即运行速度和线程安全。&lt;br&gt;运行速度：StringBuilder &amp;gt; StringBuffer &amp;gt; String&lt;br&gt;线程安全：StringBuffer 线程安全；StringBuilder
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangshengjian.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zhangshengjian.github.io/tags/Java/"/>
    
      <category term="String" scheme="https://zhangshengjian.github.io/tags/String/"/>
    
      <category term="StringBuffer" scheme="https://zhangshengjian.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="https://zhangshengjian.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务传播行为理解</title>
    <link href="https://zhangshengjian.github.io/2019/06/24/Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%90%86%E8%A7%A3/"/>
    <id>https://zhangshengjian.github.io/2019/06/24/Spring-事务传播行为理解/</id>
    <published>2019-06-24T03:05:12.000Z</published>
    <updated>2019-06-25T02:15:48.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>RE: <a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013341344</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring 在 TransactionDefinition 接口中规定了7种类型的事务传播行为。事务传播行为是 Spring 框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是 Spring 为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过 “service 方法事务最好不要嵌套” 的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h3><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><p>用伪代码说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void methodA() &#123;</span><br><span class="line">    methodB();</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Transaction(Propagation=XXX)</span><br><span class="line">public void methodB() &#123;</span><br><span class="line">    //doSomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中 methodA() 方法嵌套调用了 methodB() 方法，methodB() 的事务传播行为由@Transaction(Propagation=XXX) 设置决定。这里需要注意的是 methodA() 并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p><h3 id="Spring-中七种事务传播行为"><a href="#Spring-中七种事务传播行为" class="headerlink" title="Spring 中七种事务传播行为"></a>Spring 中七种事务传播行为</h3><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</td></tr></tbody></table><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>文中代码以传统三层结构中两层呈现，即 Service 和 Dao 层，由 Spring 负责依赖注入和注解式事务管理，DAO 层由 Mybatis 实现，你也可以使用任何喜欢的方式，例如，Hibernate,JPA,JDBCTemplate 等。数据库使用的是 MySQL 数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。</p><p>首先我们在数据库中创建两张表：</p><p><strong>user1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user1` (</span><br><span class="line">  `id` INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(45) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY(`id`)</span><br><span class="line">)</span><br><span class="line">ENGINE = InnoDB;</span><br></pre></td></tr></table></figure></p><p><strong>user2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user2` (</span><br><span class="line">  `id` INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(45) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY(`id`)</span><br><span class="line">)</span><br><span class="line">ENGINE = InnoDB;</span><br></pre></td></tr></table></figure></p><p>然后编写相应的Bean和DAO层代码：</p><p><strong>User1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User1 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    // get 和 set 方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User2 &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    // get 和 set 方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User1Mapper</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    int insert(User1 record);</span><br><span class="line">    User1 selectByPrimaryKey(Integer id);</span><br><span class="line">    // 其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User2Mapper</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface User2Mapper &#123;</span><br><span class="line">    int insert(User2 record);</span><br><span class="line">    User2 selectByPrimaryKey(Integer id);</span><br><span class="line">    // 其他方法省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后也是具体验证的代码由 service 层实现，下面我们分情况列举。</p><h3 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h3><p>我们为User1Service和User2Service相应方法加上Propagation.REQUIRED属性。</p><p><strong>User1Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User2Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void addRequiredException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p>此场景外围方法没有开启事务。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_required_required() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_required_required_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均插入。</td><td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong><em>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下 Propagation.REQUIRED 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</em></strong></p><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><p>外围方法开启事务，这个是使用率比较高的场景。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_required() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequired(user2);</span><br><span class="line">    </span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_required_required_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiredException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法3：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_required_required_exception_try() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiredException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td>2</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，外围方法感知异常致使整体事务回滚。</td></tr><tr><td>3</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部方法加入外围方法事务，内部方法抛出异常回滚，即使方法被 catch 不被外围方法感知，整个事务依然回滚。</td></tr></tbody></table><p><strong><em>结论：以上试验结果我们证明在外围方法开启事务的情况下 Propagation.REQUIRED 修饰的内部方法会加入到外围方法的事务中，所有 Propagation.REQUIRED 修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</em></strong></p><h3 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h3><p>我们为 User1Service 和 User2Service 相应方法加上 Propagation.REQUIRES_NEW 属性。<br><strong>User1Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void addRequired(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User2Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNew(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void addRequiresNewException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="场景一-1"><a href="#场景一-1" class="headerlink" title="场景一"></a>场景一</h4><p>外围方法没有开启事务。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_requiresNew_requiresNew() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_requiresNew_requiresNew_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequiresNew(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”插入，“李四”插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入。</td><td>外围方法没有开启事务，插入“张三”方法和插入“李四”方法分别开启自己的事务，插入“李四”方法抛出异常回滚，其他事务不受影响。</td></tr></tbody></table><p><strong><em>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下 Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</em></strong></p><h4 id="场景二-1"><a href="#场景二-1" class="headerlink" title="场景二"></a>场景二</h4><p>外围方法开启事务。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">public void transaction_exception_required_requiresNew_requiresNew()&#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3 = new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user3);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3 = new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    user2Service.addRequiresNewException(user3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法3：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">public void transaction_required_requiresNew_requiresNew_exception_try() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addRequired(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addRequiresNew(user2);</span><br><span class="line">    </span><br><span class="line">    User2 user3 = new User2();</span><br><span class="line">    user3.setName(&quot;王五&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addRequiresNewException(user3);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”未插入，“李四”插入，“王五”插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“张三”的方法回滚。</td></tr><tr><td>2</td><td>“张三”未插入，“李四”插入，“王五”未插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入 “王五”方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入“张三”方法也被回滚。</td></tr><tr><td>3</td><td>“张三”插入，“李四”插入，“王五”未插入。</td><td>外围方法开启事务，插入“张三”方法和外围方法一个事务，插入“李四”方法、插入“王五”方法分别在独立的新建事务中。插入“王五”方法抛出异常，首先插入“王五”方法的事务被回滚，异常被catch不会被外围方法感知，外围方法事务不回滚，故插入“张三”方法插入成功。</td></tr></tbody></table><p><strong><em>结论：在外围方法开启事务的情况下 Propagation.REQUIRES_NEW 修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</em></strong></p><h3 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h3><p>我们为 User1Service 和 User2Service 相应方法加上 Propagation.NESTED 属性。<br><strong>User1Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User1ServiceImpl implements User1Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void addNested(User1 user)&#123;</span><br><span class="line">        user1Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>User2Service方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class User2ServiceImpl implements User2Service &#123;</span><br><span class="line">    // 省略其他...</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void addNested(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void addNestedException(User2 user)&#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="场景一-2"><a href="#场景一-2" class="headerlink" title="场景一"></a>场景一</h4><p>此场景外围方法没有开启事务。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_exception_nested_nested() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void notransaction_nested_nested_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均插入。</td><td>外围方法未开启事务，插入“张三”、“李四”方法在自己的事务中独立运行，外围方法异常不影响内部插入“张三”、“李四”方法独立的事务。</td></tr><tr><td>2</td><td>“张三”插入，“李四”未插入。</td><td>外围方法没有事务，插入“张三”、“李四”方法都在自己的事务中独立运行,所以插入“李四”方法抛出异常只会回滚插入“李四”方法，插入“张三”方法不受影响。</td></tr></tbody></table><p><strong><em>结论：通过这两个方法我们证明了在外围方法未开启事务的情况下 Propagation.NESTED 和 Propagation.REQUIRED 作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</em></strong></p><h4 id="场景二-2"><a href="#场景二-2" class="headerlink" title="场景二"></a>场景二</h4><p>外围方法开启事务。<br><strong>验证方法1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_exception_nested_nested() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNested(user2);</span><br><span class="line">    throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    user2Service.addNestedException(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证方法3：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public void transaction_nested_nested_exception_try() &#123;</span><br><span class="line">    User1 user1 = new User1();</span><br><span class="line">    user1.setName(&quot;张三&quot;);</span><br><span class="line">    user1Service.addNested(user1);</span><br><span class="line">    </span><br><span class="line">    User2 user2 = new User2();</span><br><span class="line">    user2.setName(&quot;李四&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        user2Service.addNestedException(user2);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;方法回滚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分别执行验证方法，结果：</p><table><thead><tr><th>验证方法序号</th><th>数据库结果</th><th>结果分析</th></tr></thead><tbody><tr><td>1</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。</td></tr><tr><td>2</td><td>“张三”、“李四”均未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，内部方法抛出异常回滚，且外围方法感知异常致使整体事务回滚。</td></tr><tr><td>3</td><td>“张三”插入、“李四”未插入。</td><td>外围方法开启事务，内部事务为外围事务的子事务，插入“张三”内部方法抛出异常，可以单独对子事务回滚。</td></tr></tbody></table><p><strong><em>结论：以上试验结果我们证明在外围方法开启事务的情况下 Propagation.NESTED 修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务。</em></strong></p><h3 id="REQUIRED-REQUIRES-NEW-NESTED-异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED-异同" class="headerlink" title="REQUIRED,REQUIRES_NEW,NESTED 异同"></a>REQUIRED,REQUIRES_NEW,NESTED 异同</h3><p>由“1.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong><em>NESTED 和 REQUIRED 修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是 REQUIRED 是加入外围方法事务，所以和外围事务同属于一个事务，一旦 REQUIRED 事务抛出异常被回滚，外围方法事务也将被回滚。而 NESTED 是外围方法的子事务，有单独的保存点，所以 NESTED 方法抛出异常被回滚，不会影响到外围方法的事务。</em></strong></p><p>由“2.2 场景二”和“3.2 场景二”对比，我们可知：<br><strong><em>NESTED 和 REQUIRES_NEW 都可以做到内部方法事务回滚而不影响外围方法事务。但是因为 NESTED 是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而 REQUIRES_NEW 是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</em></strong></p><h3 id="其他事务传播行为"><a href="#其他事务传播行为" class="headerlink" title="其他事务传播行为"></a>其他事务传播行为</h3><p>鉴于文章篇幅问题，其他事务传播行为的测试就不在此一一描述了，感兴趣的读者可以去源码中自己寻找相应测试代码和结果解释。传送门：<a href="https://github.com/TmTse/transaction-test" target="_blank" rel="noopener">https://github.com/TmTse/transaction-test</a></p><h2 id="模拟用例"><a href="#模拟用例" class="headerlink" title="模拟用例"></a>模拟用例</h2><p>介绍了这么多事务传播行为，我们在实际工作中如何应用呢？下面我来举一个示例：</p><p>假设我们有一个注册的方法，方法中调用添加积分的方法，如果我们希望添加积分不会影响注册流程（即添加积分执行失败回滚不能使注册方法也回滚），我们会这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void register(User user) &#123;</span><br><span class="line">               </span><br><span class="line">        try &#123;</span><br><span class="line">            membershipPointService.addPoint(Point point);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           // 省略...</span><br><span class="line">        &#125;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还规定注册失败要影响 addPoint() 方法（注册方法回滚添加积分方法也需要回滚），那么 addPoint() 方法就需要这样实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MembershipPointServiceImpl implements MembershipPointService &#123;</span><br><span class="line">    </span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void addPoint(Point point) &#123;</span><br><span class="line">               </span><br><span class="line">        try &#123;</span><br><span class="line">            recordService.addRecord(Record record);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           // 省略...</span><br><span class="line">        &#125;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到了在 addPoint() 中还调用了 addRecord() 方法，这个方法用来记录日志。他的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RecordServiceImpl implements RecordService &#123;</span><br><span class="line">    </span><br><span class="line">    @Transactional(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line">    public void addRecord(Record record) &#123;</span><br><span class="line">               </span><br><span class="line">       </span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到 addRecord() 方法中 propagation = Propagation.NOT_SUPPORTED，因为对于日志无所谓精确，可以多一条也可以少一条，所以 addRecord() 方法本身和外围 addPoint() 方法抛出异常都不会使 addRecord() 方法回滚，并且 addRecord() 方法抛出异常也不会影响外围 addPoint() 方法的执行。</p><p>通过这个例子相信大家对事务传播行为的使用有了更加直观的认识，通过各种属性的组合确实能让我们的业务实现更加灵活多样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面的介绍，相信大家对 Spring 事务传播行为有了更加深入的理解，希望大家日常开发工作有所帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;RE: &lt;a href=&quot;https://segmentfault.com/a/1190000013341344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/11900000
      
    
    </summary>
    
      <category term="Spring" scheme="https://zhangshengjian.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://zhangshengjian.github.io/tags/Spring/"/>
    
      <category term="事务" scheme="https://zhangshengjian.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 入门</title>
    <link href="https://zhangshengjian.github.io/2019/06/19/Oracle-%E5%85%A5%E9%97%A8/"/>
    <id>https://zhangshengjian.github.io/2019/06/19/Oracle-入门/</id>
    <published>2019-06-19T13:40:38.000Z</published>
    <updated>2019-06-20T07:07:40.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oracle-入门学习"><a href="#Oracle-入门学习" class="headerlink" title="Oracle 入门学习"></a>Oracle 入门学习</h2><h4 id="Oracle-官网"><a href="#Oracle-官网" class="headerlink" title="Oracle 官网"></a>Oracle 官网</h4><blockquote><p>官网下载网址 <a href="https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html</a></p></blockquote><h4 id="Database-Control-URL"><a href="#Database-Control-URL" class="headerlink" title="Database Control URL"></a>Database Control URL</h4><p><a href="https://localhost:1158/em" target="_blank" rel="noopener">https://localhost:1158/em</a></p><h4 id="系统用户"><a href="#系统用户" class="headerlink" title="系统用户"></a>系统用户</h4><ul><li>sys,system</li><li>sysman</li><li>scott - 默认密码是 tiger</li></ul><h5 id="使用系统用户登录"><a href="#使用系统用户登录" class="headerlink" title="使用系统用户登录"></a>使用系统用户登录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[username/password][@server][as sysdba|sysoper]</span><br><span class="line"></span><br><span class="line">system/root @orcl as sysdba (orcl 就是自己设置的服务名)</span><br></pre></td></tr></table></figure><p>使用 system 用户登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入用户名：system/root</span><br><span class="line"></span><br><span class="line">connect sys/root as sysdba;</span><br></pre></td></tr></table></figure><h5 id="查看登录用户"><a href="#查看登录用户" class="headerlink" title="查看登录用户"></a>查看登录用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show user</span><br></pre></td></tr></table></figure><h5 id="启用-scott-用户"><a href="#启用-scott-用户" class="headerlink" title="启用 scott 用户"></a>启用 scott 用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER user username account unlock;</span><br><span class="line"></span><br><span class="line">connect scott/tiger</span><br></pre></td></tr></table></figure><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><p>dba_users 系统用户<br>user_users 普通用户<br>dba_tablespaces 系统管理员级别的用户对应的表空间（表）</p><ul><li>SYSTEM（存储 system 用户的表、视图以及存储过程等数据库对象，称为系统表空间）</li><li>SYSAUX（EXAMPLE 的辅助表空间）</li><li>UNDOTBS1（存储撤销信息的，属于 UNDO 类型的表空间）</li><li>TEMP（存储 SQL 语句处理的表和索引信息，属于临时表空间）</li><li>USERS（存储数据库用户创建的数据库对象，永久性表空间）</li><li>EXAMPLE（用于安装 Oracle 11g 数据库示例来使用的表空间）<br>user_tablespaces 普通用户对应的表空间（表）<br>dba_data_files 表空间文件数据字典<br>dba_temp_files 临时表空间文件数据字典<br>user_constraints 约束的数据字典</li></ul><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>数据库的逻辑存储空间，在数据库中开辟的空间用于存储数据库中的对象。<br>表空间是由一个或多个数据文件构成的。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>永久表空间（存储表、视图等）</li><li>临时表空间（存储数据库操作过程中，中间执行的过程，执行结束后会自动释放）</li><li>UNDO 表空间（用于保存事务所修改数据的旧值，即被修改之前的数据）</li></ul><h4 id="设置用户的默认-临时表空间"><a href="#设置用户的默认-临时表空间" class="headerlink" title="设置用户的默认/临时表空间"></a>设置用户的默认/临时表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER username DEFAULT|TEMPORARY TABLESPACE tablespace_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER USER system DEFAULT TABLESPACE system;</span><br></pre></td></tr></table></figure><h4 id="创建表空间-临时表空间"><a href="#创建表空间-临时表空间" class="headerlink" title="创建表空间/临时表空间"></a>创建表空间/临时表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [TEMPORARY] TABLESPACE tablespace_name TEMPFILE|DATAFILE &apos;xxx.dbf&apos; SIZE xx;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLESPACE test1_tablespace DATAFILE &apos;test1file.dbf&apos; SIZE 10m;</span><br><span class="line">CREATE TEMPORARY TABLESPACE temp1_tablespace TEMPFILE &apos;temp1file.dbf&apos; SIZE 10m;</span><br></pre></td></tr></table></figure><h4 id="查看表空间文件具体路径"><a href="#查看表空间文件具体路径" class="headerlink" title="查看表空间文件具体路径"></a>查看表空间文件具体路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT file_name,tablespace_name FROM dba_data_files;</span><br><span class="line"></span><br><span class="line">SELECT file_name FROM dba_data_files WHERE tablespace_name = &apos;TEST1_TABLESPACE&apos;;</span><br></pre></td></tr></table></figure><h4 id="修改表空间状态"><a href="#修改表空间状态" class="headerlink" title="修改表空间状态"></a>修改表空间状态</h4><h5 id="设置联机或脱机状态"><a href="#设置联机或脱机状态" class="headerlink" title="设置联机或脱机状态"></a>设置联机或脱机状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name ONLINE|OFFLINE;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLESPACE test1_tablespace OFFLINE;</span><br><span class="line">ALTER TABLESPACE test1_tablespace ONLINE;</span><br><span class="line">SELECT status FROM dba_tablespace WHERE tablespace_name = &apos;TEST1_TABLESPACE&apos;;</span><br></pre></td></tr></table></figure><h5 id="设置只读或读写状态"><a href="#设置只读或读写状态" class="headerlink" title="设置只读或读写状态"></a>设置只读或读写状态</h5><p>不管是修改成只读还是读写状态，表空间的状态必须是联机状态，即 status = ONLINE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name READ ONLY|READ WRITE;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLESPACE test1_tablespace READ ONLY;</span><br><span class="line">SELECT status FROM dba_tablespace WHERE tablespace_name = &apos;TEST1_TABLESPACE&apos;;</span><br><span class="line">ALTER TABLESPACE test1_tablespace READ WRITE;</span><br></pre></td></tr></table></figure><h4 id="表空间数据文件"><a href="#表空间数据文件" class="headerlink" title="表空间数据文件"></a>表空间数据文件</h4><h5 id="增加数据文件"><a href="#增加数据文件" class="headerlink" title="增加数据文件"></a>增加数据文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name ADD DATAFILE &apos;xx.dbf&apos; SIZE xx;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLESPACE test1_tablespace ADD DATAFILE &apos;test2file.dbf&apos; SIZE 10m;</span><br><span class="line">SELECT file_name FROM dba_data_files WHERE tablespace_name = &apos;TEST1_TABLESPACE&apos;;</span><br></pre></td></tr></table></figure><h5 id="删除数据文件"><a href="#删除数据文件" class="headerlink" title="删除数据文件"></a>删除数据文件</h5><p>不能删除表空间创建时第一个数据文件，如果要删除需要把整个表空间删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLESPACE tablespace_name DROP DATAFILE &apos;filename.dbf&apos;;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLESPACE test1_tablespace DROP DATAFILE &apos;test2file.dbf&apos;;</span><br><span class="line">SELECT file_name FROM dba_data_files WHERE tablespace_name = &apos;TEST1_TABLESPACE&apos;;</span><br></pre></td></tr></table></figure><h4 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLESPACE tablespace_name [INCLUDING CONTENTS];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">DROP TABLESPACE test1_tablespace INCLUDING CONTENTS;</span><br></pre></td></tr></table></figure><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h5><ul><li>CHAR(N)<br>MAX(N) = 2000</li><li>NCHAR(N)<br>MAX(N) = 1000<br>支持按照 unicode 编码方式来存放数据的，一般情况下用 NCHAR 来存储汉字比较多的</li><li>VARCHAR2(N)<br>MAX(N) = 4000<br>可变长度的数据类型</li><li>NVARCHAR2(N)<br>MAX(N) = 2000<br>支持按照 unicode 编码方式来存放数据的</li></ul><h5 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h5><ul><li>NUMBER(p,s)<br>p 有效数字；s 小数点后的位数<br>eg: NUMBER(5,2) 有效数字5位，保留2位小数，如123.45</li><li>FLOAT(N)<br>主要用来存储二进制数据的，能表示的二进制 1-126位</li></ul><h5 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h5><ul><li>DATE<br>DATE 类型表示范围：<br>公元前4712年1月1日到公元9999年12月31日 可以精确到秒</li><li>TIMESTAMP<br>时间戳类型，可以精确到小数秒</li></ul><h5 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h5><ul><li>BLOB<br>可以存放4G的数据，以二进制的形式来存放</li><li>CLOB<br>可以存放4G的数据，以字符串的形式来存放</li></ul><h4 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br><span class="line">&#123;</span><br><span class="line">column_name datatype, ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo</span><br><span class="line">(</span><br><span class="line">id number(6,0),</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    userpwd varchar2(20),</span><br><span class="line">    email varchar2(30),</span><br><span class="line">    regdate date</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo2</span><br><span class="line">(</span><br><span class="line">id number(6,0),</span><br><span class="line">    regdate date default sysdate</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">desc userinfo;</span><br></pre></td></tr></table></figure><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD column_name datatype;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo ADD remark varchar2(500);</span><br></pre></td></tr></table></figure><h5 id="更改字段数据类型"><a href="#更改字段数据类型" class="headerlink" title="更改字段数据类型"></a>更改字段数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY column_name datatype;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo MODIFY remark varchar2(400);</span><br><span class="line">ALTER TABLE userinfo MODIFY userpwd number(6,0);</span><br></pre></td></tr></table></figure><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo DROP COLUMN remark;</span><br></pre></td></tr></table></figure><h5 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo RENAME COLUMN email TO usermail;</span><br></pre></td></tr></table></figure><h5 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RENAME table_name TO new_table_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">RENAME userinfo TO user_info;</span><br></pre></td></tr></table></figure><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><h6 id="删除表中数据"><a href="#删除表中数据" class="headerlink" title="删除表中数据"></a>删除表中数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE table_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">TRUNCATE TABLE user_info;</span><br></pre></td></tr></table></figure><h6 id="删除表结构和表中数据"><a href="#删除表结构和表中数据" class="headerlink" title="删除表结构和表中数据"></a>删除表结构和表中数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">DROP TABLE user_info;</span><br></pre></td></tr></table></figure><h4 id="操作表数据"><a href="#操作表数据" class="headerlink" title="操作表数据"></a>操作表数据</h4><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p>如果把表中所有字段都插入数据，那么 table_name 后的列名可以省略，同时 value 值需要与每个字段的数据类型一一匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(column1,column2,...) VALUES(value1,value2,...);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">INSERT INTO userinfo VALUES(1,&apos;zhangshengjian&apos;,&apos;root&apos;,&apos;2695118008@qq.com&apos;,sysdate);</span><br><span class="line">INSERT INTO userinfo(id,username) VALUES(2,&apos;zsj&apos;);</span><br></pre></td></tr></table></figure><h5 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h5><h6 id="在创建表时复制表数据"><a href="#在创建表时复制表数据" class="headerlink" title="在创建表时复制表数据"></a>在创建表时复制表数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_new AS SELECT column1,... | * FROM table_old;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_new AS SELECT * FROM userinfo;</span><br><span class="line">CREATE TABLE userinfo_new1 AS SELECT id,username FROM userinfo;</span><br></pre></td></tr></table></figure><h6 id="在添加数据时复制表数据"><a href="#在添加数据时复制表数据" class="headerlink" title="在添加数据时复制表数据"></a>在添加数据时复制表数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_new [(column1,...)] SELECT column1,... | * FROM table_old;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">INSERT INTO userinfo_new SELECT * FROM userinfo;</span><br><span class="line">INSERT INTO userinfo_new(id,username) SELECT id,username FROM userinfo;</span><br></pre></td></tr></table></figure><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET column1=value1,... [WHERE conditions];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">UPDATE userinfo SET userpwd = &apos;111111&apos;;</span><br><span class="line">UPDATE userinfo SET userpwd = &apos;222222&apos;,email = &apos;111@163.com&apos;;</span><br><span class="line">UPDATE userinfo SET userpwd = &apos;333333&apos;,email = &apos;333@163.com&apos; WHERE id = 1;</span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE conditions];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">DELETE FROM userinfo;</span><br><span class="line">DELETE FROM userinfo WHERE id = 1;</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><h5 id="在创建表时设置非空约束"><a href="#在创建表时设置非空约束" class="headerlink" title="在创建表时设置非空约束"></a>在创建表时设置非空约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">column_name datatype NOT NULL,...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo(</span><br><span class="line">id number(6,0),</span><br><span class="line">    username varchar2(20) not null,</span><br><span class="line">    userpwd varchar2(20) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="在修改表时添加非空约束"><a href="#在修改表时添加非空约束" class="headerlink" title="在修改表时添加非空约束"></a>在修改表时添加非空约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY column_name datatype NOT NULL;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo MODIFY username varchar2(20) NOT NULL;</span><br></pre></td></tr></table></figure><h5 id="在修改表时去除非空约束"><a href="#在修改表时去除非空约束" class="headerlink" title="在修改表时去除非空约束"></a>在修改表时去除非空约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name MODIFY column_name varchar2(20) NULL;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo MODIFY username varchar2(20) NULL;</span><br></pre></td></tr></table></figure><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><h5 id="在创建表时设置主键约束"><a href="#在创建表时设置主键约束" class="headerlink" title="在创建表时设置主键约束"></a>在创建表时设置主键约束</h5><p>一张表只能设计一个主键约束。<br>主键约束可以由多个字段构成（联合主键或复合主键）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">column_name datatype PRIMARY KEY,...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo(</span><br><span class="line">id number(6,0) primary key,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    userpwd varchar2(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name PRIMARY KEY(column_name1,...);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo(</span><br><span class="line">id number(6,0),</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    userpwd varchar2(20),</span><br><span class="line">    CONSTRAINT pk_id_username PRIMARY KEY(id,username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SELECT constraint_name FROM user_constraints WHERE table_name = &apos;USERINFO&apos;;</span><br></pre></td></tr></table></figure><h5 id="在修改表时添加主键约束"><a href="#在修改表时添加主键约束" class="headerlink" title="在修改表时添加主键约束"></a>在修改表时添加主键约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD CONSTRAINT constraint_name PRIMARY KEY(column_name1,...);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo ADD CONSTRAINT pk_id PRIMARY KEY(id);</span><br><span class="line"></span><br><span class="line">SELECT constraint_name FROM user_constraints WHERE table_name = &apos;USERINFO&apos;;</span><br></pre></td></tr></table></figure><h5 id="更改约束的名称"><a href="#更改约束的名称" class="headerlink" title="更改约束的名称"></a>更改约束的名称</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RENAME CONSTRAINT old_name TO new_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo RENAME CONSTRAINT pk_id TO new_pk_id;</span><br><span class="line"></span><br><span class="line">SELECT constraint_name FROM user_constraints WHERE table_name = &apos;USERINFO&apos;;</span><br></pre></td></tr></table></figure><h5 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h5><h6 id="禁用主键约束"><a href="#禁用主键约束" class="headerlink" title="禁用主键约束"></a>禁用主键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISABLE|ENABLE CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo DISABLE CONSTRAINT new_pk_id;</span><br><span class="line"></span><br><span class="line">SELECT constraint_name,status FROM user_constraints WHERE table_name = &apos;USERINFO&apos;;</span><br></pre></td></tr></table></figure><h6 id="删除主键约束-1"><a href="#删除主键约束-1" class="headerlink" title="删除主键约束"></a>删除主键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">DROP PRIMARY KEY [CASCADE];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo DROP CONSTRAINT new_pk_id;</span><br><span class="line"></span><br><span class="line">SELECT constraint_name,status FROM user_constraints WHERE table_name = &apos;USERINFO&apos;;</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><h5 id="在创建表时设置外键约束"><a href="#在创建表时设置外键约束" class="headerlink" title="在创建表时设置外键约束"></a>在创建表时设置外键约束</h5><h6 id="列级外键约束"><a href="#列级外键约束" class="headerlink" title="列级外键约束"></a>列级外键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table1(</span><br><span class="line">column_name datatype REFERENCES table2(column_name),...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE typeinfo(</span><br><span class="line">typeid varchar2(10) primary key,</span><br><span class="line">    typename varchar2(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE userinfo_f(</span><br><span class="line">id varchar2(10) primary key,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    typeid_new varchar2(10) references typeinfo(typeid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO typeinfo VALUES(1,1);</span><br><span class="line">INSERT INTO userinfo_f(id,typeid_new) VALUES(1,1);</span><br><span class="line">INSERT INTO userinfo_f(id,typeid_new) VALUES(1,NULL);</span><br><span class="line"></span><br><span class="line">// 违反完整约束条件 - 未找到父项关键字</span><br><span class="line">INSERT INTO userinfo_f(id,typeid_new) VALUES(1,2);</span><br></pre></td></tr></table></figure><p>table1 一般称为从表，table2 一般称为主表，外键约束一般称为主从表的关系。<br>设置外键约束时，主表的字段必须是主键。<br>主从表中相应的字段必须是同一个数据类型。<br>从表中外键字段的值必须来自主表中的相应字段的值，或者为 null 值。</p><h6 id="表级外键约束"><a href="#表级外键约束" class="headerlink" title="表级外键约束"></a>表级外键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES table_name(column_name) [ON DELETE CASCADE];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_f2(</span><br><span class="line">id varchar2(10) primary key,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    typeid_new varchar2(10),</span><br><span class="line">    CONSTRAINT fk_typeid_new FOREIGN KEY(typeid_new) REFERENCES typeinfo(typeid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE userinfo_f3(</span><br><span class="line">id varchar2(10) primary key,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    typeid_new varchar2(10),</span><br><span class="line">    CONSTRAINT fk_typeid_new1 FOREIGN KEY(typeid_new) REFERENCES typeinfo(typeid)</span><br><span class="line">    ON DELETE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="在修改表时设置外键约束"><a href="#在修改表时设置外键约束" class="headerlink" title="在修改表时设置外键约束"></a>在修改表时设置外键约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ADD CONSTRAINT constraint_name FOREIGN KEY(column_name) REFERENCES table_name(column_name) [ON DELETE CASCADE];</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_f4(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    typeid_new varchar2(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo_f4</span><br><span class="line">ADD CONSTRAINT fk_typeid_alter FOREIGN KEY(typeid_new) REFERENCES typeinfo(typeid);</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo_f4</span><br><span class="line">ADD CONSTRAINT fk_typeid_alter FOREIGN KEY(typeid_new) REFERENCES typeinfo(typeid)</span><br><span class="line">ON DELETE CASCADE;</span><br></pre></td></tr></table></figure><h5 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h5><h6 id="禁用外键约束"><a href="#禁用外键约束" class="headerlink" title="禁用外键约束"></a>禁用外键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISABLE|ENABLE CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">SELECT constraint_name,constraint_type,status FROM user_constraints WHERE table_name = &apos;USERINFO_F4&apos;;</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo_f4 DISABLE CONSTRAINT FK_TYPEID_ALTER;</span><br></pre></td></tr></table></figure><h6 id="删除外键约束-1"><a href="#删除外键约束-1" class="headerlink" title="删除外键约束"></a>删除外键约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo_f4 DROP CONSTRAINT FK_TYPEID_ALTER;</span><br><span class="line"></span><br><span class="line">SELECT constraint_name,constraint_type,status FROM user_constraints WHERE table_name = &apos;USERINFO_F4&apos;;</span><br></pre></td></tr></table></figure><h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><h5 id="在创建表时设置唯一约束"><a href="#在创建表时设置唯一约束" class="headerlink" title="在创建表时设置唯一约束"></a>在创建表时设置唯一约束</h5><p>唯一约束和主键约束的区别：<br>主键字段值必须是非空的，唯一约束允许有一个空值。<br>主键在每张表中只能有一个，唯一约束在每张表中可以有多个。</p><h6 id="列级唯一约束"><a href="#列级唯一约束" class="headerlink" title="列级唯一约束"></a>列级唯一约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">column_name datatype UNIQUE,...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_u(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20) UNIQUE,</span><br><span class="line">    userpwd varchar2(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="表级唯一约束"><a href="#表级唯一约束" class="headerlink" title="表级唯一约束"></a>表级唯一约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name UNIQUE(column_name);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_u1(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    CONSTRAINT un_username UNIQUE(username)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="在修改表时设置唯一约束"><a href="#在修改表时设置唯一约束" class="headerlink" title="在修改表时设置唯一约束"></a>在修改表时设置唯一约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADD CONSTRAINT constraint_name UNIQUE(column_name);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_u2(</span><br><span class="line">id varchar2(10) primary key,</span><br><span class="line">    username varchar2(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo_u2 ADD CONSTRAINT un_username_new UNIQUE(username);</span><br></pre></td></tr></table></figure><h5 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h5><h6 id="禁用唯一约束"><a href="#禁用唯一约束" class="headerlink" title="禁用唯一约束"></a>禁用唯一约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DISABLE|ENABLE CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo_u2 DISABLE CONSTRAINT UN_USERNAME_NEW;</span><br><span class="line">SELECT constraint_name,constraint_type,status FROM user_constraints WHERE table_name=&apos;USERINFO_U2&apos;;</span><br></pre></td></tr></table></figure><h6 id="删除唯一约束-1"><a href="#删除唯一约束-1" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT constraint_name;</span><br></pre></td></tr></table></figure><h4 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h4><h5 id="在创建表时设置检查约束"><a href="#在创建表时设置检查约束" class="headerlink" title="在创建表时设置检查约束"></a>在创建表时设置检查约束</h5><h6 id="列级检查约束"><a href="#列级检查约束" class="headerlink" title="列级检查约束"></a>列级检查约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">column_name datatype CHECK(expressions),...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_c(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    salary number(5,0) CHECK(salary&gt;0)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="表级检查约束"><a href="#表级检查约束" class="headerlink" title="表级检查约束"></a>表级检查约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT constraint_name CHECK(expressions);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_c1(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    salary number(5,0),</span><br><span class="line">    CONSTRAINT ck_salary CHECK(salary&gt;0)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="在修改表时设置检查约束"><a href="#在修改表时设置检查约束" class="headerlink" title="在修改表时设置检查约束"></a>在修改表时设置检查约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADD CONSTRAINT constraint_name CHECK(expressions);</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">CREATE TABLE userinfo_c3(</span><br><span class="line">id varchar2(10) PRIMARY KEY,</span><br><span class="line">    username varchar2(20),</span><br><span class="line">    salary number(5,0)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE userinfo_c3 ADD CONSTRAINT ck_salary_new CHECK(salary&gt;0);</span><br></pre></td></tr></table></figure><h5 id="删除检查约束"><a href="#删除检查约束" class="headerlink" title="删除检查约束"></a>删除检查约束</h5><h6 id="禁用检查约束"><a href="#禁用检查约束" class="headerlink" title="禁用检查约束"></a>禁用检查约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISABLE|ENABLE CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo_c3 DISABLE CONSTRAINT CK_SALARY_NEW;</span><br></pre></td></tr></table></figure><h6 id="删除检查约束-1"><a href="#删除检查约束-1" class="headerlink" title="删除检查约束"></a>删除检查约束</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP CONSTRAINT constraint_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">ALTER TABLE userinfo_c3 DROP CONSTRAINT CK_SALARY_NEW;</span><br></pre></td></tr></table></figure><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><h4 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a>基本查询语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT] column_name1,...|* FROM table_name [WHERE conditions];</span><br></pre></td></tr></table></figure><h4 id="SQL-PLUS-设置"><a href="#SQL-PLUS-设置" class="headerlink" title="SQL*PLUS 设置"></a>SQL*PLUS 设置</h4><h5 id="设置用户名"><a href="#设置用户名" class="headerlink" title="设置用户名"></a>设置用户名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">COLUMN column_name HEADING new_name;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">COL username HEADING 用户名;</span><br><span class="line">COLUMN username HEADING 用户名;</span><br><span class="line">SELECT * FROM users;</span><br></pre></td></tr></table></figure><h5 id="设置结果格式"><a href="#设置结果格式" class="headerlink" title="设置结果格式"></a>设置结果格式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">COLUMN column_name FORMAT dataformat;</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">// 设置字符型格式用 &quot;a&quot;</span><br><span class="line">COL username FORMAT a10;</span><br><span class="line">SELECT * FROM users;</span><br><span class="line">// 设置数字格式用 &quot;9&quot;，如果设置的长度超过了数据的长度用 &quot;#&quot; 代替</span><br><span class="line">COL salary FORMAT 9999.9;</span><br><span class="line">COL salary FORMAT $9999.9;</span><br></pre></td></tr></table></figure><p>注：字符类型只能设置显示的长度。</p><h5 id="清除格式"><a href="#清除格式" class="headerlink" title="清除格式"></a>清除格式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COLUMN column_name CLEAR;</span><br><span class="line">COL column_name CLEAR;</span><br></pre></td></tr></table></figure><h4 id="给字段设置别名"><a href="#给字段设置别名" class="headerlink" title="给字段设置别名"></a>给字段设置别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name AS new_name,... FROM table_name;</span><br></pre></td></tr></table></figure><p>注：AS 可以省略，有空格隔开原来的字段名和新字段名即可。</p><h4 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h4><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符 +, -, *, /"></a>算术运算符 +, -, *, /</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,username,salary+200 FROM users;</span><br></pre></td></tr></table></figure><h5 id="比较运算符-gt-gt-lt-lt-lt-gt"><a href="#比较运算符-gt-gt-lt-lt-lt-gt" class="headerlink" title="比较运算符 &gt;, &gt;=, &lt;, &lt;=, =, &lt;&gt;"></a>比较运算符 &gt;, &gt;=, &lt;, &lt;=, =, &lt;&gt;</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username FROM users WHERE salary&gt;800;</span><br></pre></td></tr></table></figure><p>比较运算符的优先级高于逻辑运算符</p><h5 id="逻辑运算符-and-or-not"><a href="#逻辑运算符-and-or-not" class="headerlink" title="逻辑运算符 and, or, not"></a>逻辑运算符 and, or, not</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT username FROM users WHERE salary&gt;800 AND salary&lt;&gt;1888.5;</span><br><span class="line">SELECT * FROM users WHERE NOT(username=&apos;aaa&apos;);</span><br></pre></td></tr></table></figure><p>逻辑运算符的优先级：按 not、and、or 的顺序依次递减</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="通配符的使用（-）"><a href="#通配符的使用（-）" class="headerlink" title="通配符的使用（_ , %）"></a>通配符的使用（_ , %）</h5><p>一个 _ 只能代表一个字符<br>% 可以代表0到多个任意字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username like &apos;a%&apos;;</span><br><span class="line">SELECT * FROM users WHERE username like &apos;_a%&apos;;</span><br><span class="line">SELECT * FROM users WHERE username like &apos;%a%&apos;;</span><br></pre></td></tr></table></figure><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE salary&gt;=800 AND salary&lt;=2000;</span><br><span class="line"></span><br><span class="line">SELECT * FROM users WHERE salary BETWEEN 800 AND 2000;</span><br><span class="line"></span><br><span class="line">SELECT * FROM users WHERE salary NOT BETWEEN 800 AND 2000;</span><br><span class="line"></span><br><span class="line">SELECT * FROM users WHERE username IN(&apos;AAA&apos;,&apos;BBB&apos;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM users WHERE username NOT IN(&apos;AAA&apos;,&apos;BBB&apos;);</span><br></pre></td></tr></table></figure><h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ... [WHERE ...] ORDER BY column1 DESC/ASC, ...</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">SELECT * FROM users ORDER BY id DESC;</span><br><span class="line">SELECT * FROM users ORDER BY username DESC, salary ASC;</span><br></pre></td></tr></table></figure><h4 id="CASE-…-WHEN-语句的使用"><a href="#CASE-…-WHEN-语句的使用" class="headerlink" title="CASE … WHEN 语句的使用"></a>CASE … WHEN 语句的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE column_name WHEN value1 THEN result1, ... [ELSE result] END</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">SELECT username, CASE username WHEN &apos;aaa&apos; THEN &apos;计算机部门&apos; WHEN &apos;bbb&apos; THEN &apos;市场部门&apos; ELSE &apos;其他部门&apos; END AS 部门 FROM users;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN column_name=value1 THEN result1, ... [ELSE result] END</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">SELECT username, CASE WHEN username=&apos;aaa&apos; THEN &apos;计算机部门&apos; WHEN username=&apos;bbb&apos; THEN &apos;市场部门&apos; ELSE &apos;其他部门&apos; END AS 部门 FROM users;</span><br><span class="line"></span><br><span class="line">SELECT username, CASE WHEN salary&lt;800 THEN &apos;工资低&apos; WHEN salary&gt;5000 THEN &apos;工资高&apos; END AS 工资水平 FROM users;</span><br></pre></td></tr></table></figure><h4 id="decode-函数的使用"><a href="#decode-函数的使用" class="headerlink" title="decode 函数的使用"></a>decode 函数的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decode(column_name, value1, result1, ..., defaultvalue)</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">SELECT username,decode(username,&apos;aaa&apos;,&apos;计算机部门&apos;,&apos;bbb&apos;,&apos;市场部门&apos;,&apos;其他&apos;) AS 部门 FROM users;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Oracle-入门学习&quot;&gt;&lt;a href=&quot;#Oracle-入门学习&quot; class=&quot;headerlink&quot; title=&quot;Oracle 入门学习&quot;&gt;&lt;/a&gt;Oracle 入门学习&lt;/h2&gt;&lt;h4 id=&quot;Oracle-官网&quot;&gt;&lt;a href=&quot;#Oracle-官
      
    
    </summary>
    
      <category term="Oracle" scheme="https://zhangshengjian.github.io/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://zhangshengjian.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://zhangshengjian.github.io/2019/06/17/Docker/"/>
    <id>https://zhangshengjian.github.io/2019/06/17/Docker/</id>
    <published>2019-06-17T12:31:46.000Z</published>
    <updated>2019-06-19T13:51:42.703Z</updated>
    
    <content type="html"><![CDATA[<p><b>Docker</b></p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p></blockquote><p><b>Docker 历史</b></p><ul><li>2010 dotCloud PAAS</li><li>2013 docker 开源</li><li>2014.6 Docker 1.0</li><li>2014.7 C 轮 $4000万</li><li>2015.4 D 轮 $9500万</li><li>至今 版本</li></ul><p><b>什么是 Docker</b></p><ul><li>Docker is the world’s leading software containerization platform.</li><li>Docker 公司开发，开源，托管在 Github.</li><li>跨平台，支持 Windows、Macos、Linux.</li></ul><p><b>Docker 思想</b></p><ul><li>集装箱</li><li>标准化<ul><li>运输方式</li><li>存储方式</li><li>API 接口</li></ul></li><li>隔离</li></ul><p><b>Docker 解决了什么问题</b></p><ul><li>我本地运行没问题啊！- 运行环境不一致</li><li>系统好卡，哪个哥们又写死循环了！- 隔离性</li><li>双11来了，服务器撑不住啦！- 快速扩展，弹性伸缩变得更为简单</li></ul><p><b>技术名词</b></p><ul><li>镜像</li><li>仓库</li><li>容器</li></ul><p><b>Docker 仓库</b></p><ul><li><a href="http://hub.docker.com/" target="_blank" rel="noopener">http://hub.docker.com/</a></li><li><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/home/</a></li></ul><p><b>Docker 常用命令</b></p><ul><li>docker version 查看 docker 版本（验证 docker 是否安装成功）</li><li>docker pull [OPTIONS] NAME[:TAG] 拉取镜像</li><li>docker images [OPTIONS] [REPOSITORY[:TAG]] 查看本机都有哪些镜像</li><li>docker run [OPTIONS] IMAGE[:TAG][COMMAND][ARG…] 运行 docker<ul><li>docker run -d 在后台运行 docker 容器</li></ul></li><li>docker ps 查看 docker 进程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Docker&lt;/b&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="https://zhangshengjian.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zhangshengjian.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>HBase</title>
    <link href="https://zhangshengjian.github.io/2019/06/12/HBase/"/>
    <id>https://zhangshengjian.github.io/2019/06/12/HBase/</id>
    <published>2019-06-12T08:32:45.000Z</published>
    <updated>2019-06-12T14:25:51.194Z</updated>
    
    <content type="html"><![CDATA[<p><b>HBase 的特点</b></p><ul><li>海量数据存储</li><li>准实时查询</li></ul><p><b>HBase 的应用场景</b></p><ul><li>交通</li><li>金融</li><li>电商</li><li>移动</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;HBase 的特点&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;海量数据存储&lt;/li&gt;
&lt;li&gt;准实时查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;HBase 的应用场景&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交通&lt;/li&gt;
&lt;li&gt;金融&lt;/li&gt;
&lt;li&gt;电商&lt;/li&gt;
&lt;li&gt;移动&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://zhangshengjian.github.io/2019/06/11/Kafka/"/>
    <id>https://zhangshengjian.github.io/2019/06/11/Kafka/</id>
    <published>2019-06-11T05:56:20.000Z</published>
    <updated>2019-06-11T08:24:58.349Z</updated>
    
    <content type="html"><![CDATA[<p><b>Kafka 简介</b><br>Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它因可以水平扩展和高吞吐率而被广泛使用。</p><p><b>Kafka 基本概念</b></p><ul><li>Producer：消息和数据的生产者，向 Kafka 的一个 Topic 发布消息的进程/代码/服务</li><li>Consumer：消息和数据的消费者，订阅数据（Topic）并且处理其发布的消息的进程/代码/服务</li><li>Consumer Group：逻辑概念，对于同一个 Topic，会广播给不同的 Group，一个 Group 中，只有一个 consumer 可以消费该消息</li><li>Broker：物理概念，Kafka 集群中的每个 Kafka 节点（即Kafka 所在服务器节点）</li><li>Topic：逻辑概念，Kafka 消息的类别，对数据进行区分、隔离</li><li>Partition：物理概念，Kafka 下数据存储的基本单元。一个 Topic 数据会被分散存储到多个 Partition，每一个 Partition 是有序的</li><li>Replication：同一个 Partition 可能会有多个 Replica，多个 Replica 之间数据是一样的（相当于副本的概念）</li><li>Replication Leader：一个 Partition 的多个 Replica 上，需要一个 Leader 负责该 Partition 上与 Producer 和 Consumer 交互</li><li>RelicaManager：负责管理当前 broker 所有分区和副本的信息，处理 KafkaController 发起的一些请求，副本状态的切换、添加/读取消息等（负责 Leader 的选举）</li></ul><p><b>Partition</b></p><ul><li>每一个 Topic 被切分为多个 Partitions</li><li>消费者数目少于或等于 Partition 的数目</li><li>Broker Group 中的每一个 Broker 保存 Topic 的一个或多个 Partitions</li><li>Consumer Group 中的仅有一个 Consumer 读取 Topic 的一个或多个 Partitions，并且是唯一的 Consumer</li></ul><p><b>Replication</b></p><ul><li>当集群中有 Broker 挂掉的情况，系统可以主动地使 Replicas 提供服务</li><li>系统默认设置每一个 Topic 的 replication 系数为1，可以在创建 Topic 时单独设置</li></ul><p><b>Replication 特点</b></p><ul><li>Replication 的基本单位是 Topic 的 Partition</li><li>所有的读和写都从 Leader 进，Followers 只是作为备份</li><li>Follower 必须能够即使复制 Leader 的数据</li><li>增加容错性与可扩展性</li></ul><p><b>Kafka 基本结构</b></p><ul><li>Producer Api</li><li>Consumer Api</li><li>Streams Api</li><li>Connectors Api</li></ul><p><b>Kafka 特点</b></p><ul><li>分布式<ul><li>多分区</li><li>多副本</li><li>多订阅者</li><li>基于 Zookeeper 调度</li></ul></li><li>高性能<ul><li>高吞吐量</li><li>低延迟</li><li>高并发</li><li>时间复杂度为O(1)</li></ul></li><li>持久性与可扩展性<ul><li>数据可持久化</li><li>容错性</li><li>支持在线水平扩展</li><li>消息自动平衡</li></ul></li></ul><p><b>Kafka 应用场景</b></p><ul><li>消息队列</li><li>行为追踪</li><li>元信息监控</li><li>日志收集</li><li>流处理</li><li>事件源</li><li>持久性日志（commit log）</li></ul><p><b>Kafka 常用命令</b></p><ul><li><p>启动 Zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties</span><br></pre></td></tr></table></figure></li><li><p>启动 Broker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties</span><br></pre></td></tr></table></figure></li><li><p>查看主题列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure></li><li><p>查看单个主题详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --describe --zookeeper localhost:2181 --topic test-kafka-topic</span><br></pre></td></tr></table></figure></li><li><p>创建 Topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1</span><br><span class="line">--partitions 1 --topic test-kafka-topic</span><br></pre></td></tr></table></figure></li><li><p>生产消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test-kafka-topic</span><br></pre></td></tr></table></figure></li><li><p>查看消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic </span><br><span class="line">test-kafka-topic --from-beginning</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：–from-beginning 决定消费者是否从头开始消费</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Kafka 简介&lt;/b&gt;&lt;br&gt;Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它因可以水平扩展和高吞吐率而被广泛使用。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Kafka 基本概念&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Producer：消息和数据的
      
    
    </summary>
    
      <category term="MQ" scheme="https://zhangshengjian.github.io/categories/MQ/"/>
    
    
      <category term="Kafka" scheme="https://zhangshengjian.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Mac Pro 快捷键</title>
    <link href="https://zhangshengjian.github.io/2019/06/09/Mac-Pro-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://zhangshengjian.github.io/2019/06/09/Mac-Pro-快捷键/</id>
    <published>2019-06-09T12:33:09.000Z</published>
    <updated>2019-07-12T15:10:14.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mac Pro 常用快捷键</p></blockquote><table><thead><tr><th>快捷键</th><th>解释</th></tr></thead><tbody><tr><td>command + F3 / fn + F11</td><td>显示桌面</td></tr><tr><td>shift + command + G</td><td>打开某一指定目录</td></tr></tbody></table><blockquote><p>Mac Pro 终端常用命令</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>netstat -na &#124; grep 8080</td><td>查看端口状态</td></tr><tr><td>ssh -p port user@host</td><td>远程登录 Linux 服务器</td></tr><tr><td>sudo lsof -i:8080</td><td>查看端口占用进程</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Mac Pro 常用快捷键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;command + F3 /
      
    
    </summary>
    
      <category term="Mac" scheme="https://zhangshengjian.github.io/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://zhangshengjian.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ</title>
    <link href="https://zhangshengjian.github.io/2019/06/06/ActiveMQ/"/>
    <id>https://zhangshengjian.github.io/2019/06/06/ActiveMQ/</id>
    <published>2019-06-06T07:39:20.000Z</published>
    <updated>2019-07-06T13:58:23.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ActiveMQ 官方网址：<a href="http://activemq.apache.org" target="_blank" rel="noopener">http://activemq.apache.org</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="Java-消息服务"><a href="#Java-消息服务" class="headerlink" title="Java 消息服务"></a>Java 消息服务</h4><p>不同系统之间的信息交换，是我们开发中比较常见的场景，比如系统 A 要把数据发送给系统 B，这个问题我们应该如何去处理？1994年，原来的 Sun 公司领衔提出了一种面向消息的中间件服务–JMS 规范（标准）；常用的几种信息交互技术（httpClient、hession、dubbo、jms、webservice 五种）。</p><h4 id="JMS-概述"><a href="#JMS-概述" class="headerlink" title="JMS 概述"></a>JMS 概述</h4><p>JMS 即 Java 消息服务（Java Message Service 的简称），是 Java EE 的标准/规范之一。这种规范（标准）指出：消息的发送应该是异步的、非阻塞的。也就是说消息的发送者发送完消息后就直接返回了，不需要等待接收者返回后才能返回，发送者和接收者可以说是互不影响。所以这种规范（标准）能够减轻或消除系统瓶颈，实现系统之间去除耦合，提高系统的整体可伸缩性和灵活性。JMS 只是 Java EE 中定义的一组标准的 API，它自身并不是一个消息服务系统，它是消息传送服务的一个抽象，也就是说它定义了消息传送的接口而并没有具体实现。</p><h4 id="ActiveMQ-概述"><a href="#ActiveMQ-概述" class="headerlink" title="ActiveMQ 概述"></a>ActiveMQ 概述</h4><p>我们知道 JMS 只是消息服务的一组规范和接口，并没有具体的实现，而 ActiveMQ 就是 JMS 规范的具体实现；它是 Apache 下的一个项目，采用 Java 语言开发；是一款非常流行的开源消息服务器。</p><h4 id="ActiveMQ-与-JMS-关系"><a href="#ActiveMQ-与-JMS-关系" class="headerlink" title="ActiveMQ 与 JMS 关系"></a>ActiveMQ 与 JMS 关系</h4><p>JMS 只是定义了一组有关消息传送的规范和标准，并没有真正实现，也就是说 JMS 只是定义了一组接口而已；就像 JDBC 抽象了关系数据库访问、JPA 抽象了对象与关系数据库映射、JNDI 抽象了命名目录服务访问一样，JMS 具体的实现由不同的消息中间件厂商提供，比如 Apache ActiveMQ 就是 JMS 规范的具体实现，Apache ActiveMQ 才是一个消息服务系统，而 JMS 不是。</p><h3 id="ActiveMQ-下载地址"><a href="#ActiveMQ-下载地址" class="headerlink" title="ActiveMQ 下载地址"></a>ActiveMQ 下载地址</h3><p><a href="http://activemq.apache.org/download-archives.html" target="_blank" rel="noopener">http://activemq.apache.org/download-archives.html</a></p><hr><h3 id="ActiveMQ-依赖-JDK-版本"><a href="#ActiveMQ-依赖-JDK-版本" class="headerlink" title="ActiveMQ 依赖 JDK 版本"></a>ActiveMQ 依赖 JDK 版本</h3><table><thead><tr><th>MQ 版本号</th><th>Build-JDK</th><th>依赖 JDK</th></tr></thead><tbody><tr><td>apache-activemq-5.0.0</td><td>1.5.0_12</td><td>1.5 +</td></tr><tr><td>apache-activemq-5.1.0</td><td>1.5.0_12</td><td>1.5 +</td></tr><tr><td>apache-activemq-5.2.0</td><td>1.5.0_15</td><td>1.5 +</td></tr><tr><td>apache-activemq-5.3.0</td><td>1.5.0_17</td><td>1.5 +</td></tr><tr><td>apache-activemq-5.4.0</td><td>1.5.0_19</td><td>1.5 +</td></tr><tr><td>apache-activemq-5.5.0</td><td>1.6.0_23</td><td>1.6 +</td></tr><tr><td>apache-activemq-5.6.0</td><td>1.6.0_26</td><td>1.6 +</td></tr><tr><td>apache-activemq-5.7.0</td><td>1.6.0_33</td><td>1.6 +</td></tr><tr><td>apache-activemq-5.8.0</td><td>1.6.0_37</td><td>1.6 +</td></tr><tr><td>apache-activemq-5.9.0</td><td>1.6.0_51</td><td>1.6 +</td></tr><tr><td>apache-activemq-5.10.0</td><td>1.7.0_12-ea</td><td>1.7 +</td></tr><tr><td>apache-activemq-5.11.0</td><td>1.7.0_60</td><td>1.7 +</td></tr><tr><td>apache-activemq-5.12.0</td><td>1.7.0_80</td><td>1.7 +</td></tr><tr><td>apache-activemq-5.13.0</td><td>1.7.0_80</td><td>1.7 +</td></tr><tr><td>apache-activemq-5.14.0</td><td>1.7.0_80</td><td>1.7 +</td></tr><tr><td>apache-activemq-5.15.0</td><td>1.8.0_112</td><td>1.8 +</td></tr></tbody></table><hr><p><strong>如何查看官方发布 ActiveMQ 依赖 JDK 版本</strong><br>查看文件 activemq-all-*.jar\META-INF\MANIFEST.MF 的属性值 Build-Jdk</p><p><img src="/images/pasted-12.png" alt="图一"></p><hr><h3 id="JMS-中的关键接口"><a href="#JMS-中的关键接口" class="headerlink" title="JMS 中的关键接口"></a>JMS 中的关键接口</h3><ul><li>ConnectionFactory：用于创建连接到消息中间件的连接工厂。</li><li>Connection：代表了应用程序和服务之间的连接通路。</li><li>Destination：指消息发布的地点，包括队列模式和主体模式。</li><li>Session：表示一个单线程的上下文，用于发送和接受消息。</li><li>MessageConsumer：由会话创建，用于接受发送到目的的消息。</li><li>MessageProducer：由会话创建，用于发送消息。</li><li>Message：是在消费者和生产者之间传递的对象，消息头，一组消息属性，和一个消息体。 </li></ul><p><img src="/images/pasted-13.png" alt="图二"></p><hr><h3 id="Mac-上安装-ActiveMQ"><a href="#Mac-上安装-ActiveMQ" class="headerlink" title="Mac 上安装 ActiveMQ"></a>Mac 上安装 ActiveMQ</h3><ul><li>下载 ActiveMQ（博主准备的版本是 5.15.9）</li><li>通过命令解压到本地</li><li>启动 ActiveMQ，执行命令 ./activemq start（见图二）。启动后有两个端口号，一个是 Web 控制台的 8161，一个是消息服务 Broker 连接端口 61616</li><li>浏览器访问 <a href="http://127.0.0.1:8161/admin/" target="_blank" rel="noopener">http://127.0.0.1:8161/admin/</a> ，账号 admin 密码 admin（见图三）</li><li>成功登录（见图四）</li></ul><p><img src="/images/pasted-9.png" alt="图三"></p><p><img src="/images/pasted-10.png" alt="图四"></p><p><img src="/images/pasted-11.png" alt="图五"></p><ul><li>Home：查看 ActiveMQ 的常见信息</li><li>Queues：查看 ActiveMQ 的队列信息</li><li>Topics：查看 ActiveMQ 的主题信息</li><li>Subscribers：查看主题的订阅者信息</li><li>Connections：查看 ActiveMQ 客户端的连接信息</li><li>Network：查看 ActiveMQ 的网络信息</li><li>Scheduled：查看 ActiveMQ 的定时任务</li><li>Send：用于通过表单方式向队列或者主题发送具体的消息</li></ul><hr><p><strong>ActiveMQ 名词解释</strong></p><ul><li>Number Of Consumers 消费者端的消费者数量</li><li>Number Of Pending Messages 等待消费的消息，这个是当前未出队列的数量。可以理解为总接收数-总出队列数</li><li>Messages Enqueued 进入队列的消息，进入队列的总数量，包括出队列的。这个数量只增不减</li><li>Messages Dequeued 出了队列的消息，可以理解为是消费这消费掉的数量</li></ul><p>这个要分两种情况理解</p><p>在 queues 里出队列消息和进入队列的总数量相等（因为一个消息只会被成功消费一次）,如果暂时不等是因为消费者还没来得及消费。<br>在 topics 里出队列消息因为多消费者从而导致数量会比入队列数高。<br>简单的理解上面的意思就是<br>当有一个消息进入这个队列时，等待消费的消息是1，进入队列的消息是1；<br>当消息消费后，等待消费的消息是0，进入队列的消息是1，出队列的消息是1；<br>在来一条消息时，等待消费的消息是1，进入队列的消息就是2；</p><p>没有消费者时  Pending Messages 和入队列数量一样；<br>有消费者消费的时候 Pedding 会减少，出队列会增加；<br>到最后就是入队列和出队列的数量一样多；<br>以此类推，进入队列的消息和出队列的消息是池子，等待消费的消息是水流。</p><hr><h3 id="ActiveMQ-特点"><a href="#ActiveMQ-特点" class="headerlink" title="ActiveMQ 特点"></a>ActiveMQ 特点</h3><ul><li>支持多语言编写客户端</li><li>对 Spring 的支持，很容易和 Spring 整合</li><li>支持多种传输协议：TCP、SSL、NIO、UDP 等</li><li>支持 AJAX</li></ul><hr><h3 id="ActiveMQ-的消息模式"><a href="#ActiveMQ-的消息模式" class="headerlink" title="ActiveMQ 的消息模式"></a>ActiveMQ 的消息模式</h3><ul><li>队列消息模式</li><li>订阅模式</li></ul><h4 id="点对点的消息模式"><a href="#点对点的消息模式" class="headerlink" title="点对点的消息模式"></a>点对点的消息模式</h4><p>&emsp;&emsp;点对点的消息模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向 ActiveMQ 发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在 ActiveMQ 服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上 ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。</p><p>特点：<br>（1）客户端包括生产者和消费者；<br>（2）队列中的一个消息只能被一个消费者使用；<br>（3）消费者可以随时取消息；</p><h4 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h4><p>&emsp;&emsp;订阅/发布模式，同样可以有着多个发送端与多个接收端，但是接收端与发送端存在时间上的依赖，就是如果发送端发送消息的时候，接收端并没有监听消息，那么 ActiveMQ 将不会保存消息，将会认为消息已经发送，换一种说法，就是发送端发送消息的时候，接收端不在线，是接收不到消息的，哪怕以后监听消息，同样也是接收不到的。这个模式还有一个特点，那就是，发送端发送的消息，将会被所有的接收端给接收到，不类似点对点，一条消息只会被一个接收端给接收到。</p><p>特点：<br>（1）客户端包括发布者和订阅者；<br>（2）主题中的消息可以被所有订阅者消费；<br>（3）消费者不能消费订阅之前发送的消息；</p><hr><h4 id="点对点的消息模式和订阅模式区别"><a href="#点对点的消息模式和订阅模式区别" class="headerlink" title="点对点的消息模式和订阅模式区别"></a>点对点的消息模式和订阅模式区别</h4><ul><li><font color="red">订阅模式需要先订阅 TOPIC，即先启动消费者再启动生产者才能正常消费</font></li></ul><hr><h3 id="ActiveMQ-的安全配置"><a href="#ActiveMQ-的安全配置" class="headerlink" title="ActiveMQ 的安全配置"></a>ActiveMQ 的安全配置</h3><ul><li>管理后台的密码设置<br>打开 127.0.0.1:8161/admin/ 就是 ActiveMQ 的管理控制台，它的默认账号和密码都是 admin, 在生产环境肯定需要更改密码的，这要怎么做呢？<br>在 activemq/conf/jetty.xml 中找到</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;securityConstraint&quot; class=&quot;org.eclipse.jetty.util.security.Constraint&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;BASIC&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;roles&quot; value=&quot;user,admin&quot; /&gt;</span><br><span class="line">    &lt;!-- set authenticate=false to disable login --&gt;</span><br><span class="line">    &lt;property name=&quot;authenticate&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>高版本的已经默认成为了 true。所以我们直接进行下一步即可</p><p>在 activemq/conf/jetty-realm.properties 文件中配置，打开如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">## ---------------------------------------------------------------------------</span><br><span class="line">## Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">## contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">## this work for additional information regarding copyright ownership.</span><br><span class="line">## The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">## (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">## the License.  You may obtain a copy of the License at</span><br><span class="line">## </span><br><span class="line">## http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">## </span><br><span class="line">## Unless required by applicable law or agreed to in writing, software</span><br><span class="line">## distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">## See the License for the specific language governing permissions and</span><br><span class="line">## limitations under the License.</span><br><span class="line">## ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Defines users that can access the web (console, demo, etc.)</span><br><span class="line"># username: password [,rolename ...]</span><br><span class="line">admin: admin, admin</span><br><span class="line">user: user, user</span><br></pre></td></tr></table></figure><p>注意：重点看倒数第二行，那里三个分别是用户名，密码，角色，其中 admin 角色是固定的。</p><p>注意：ActiveMQ 默认是不需要密码，生产消费者就可以连接的。</p><p>需要经过配置，才能设置密码，这一步在生产环境中一定要配置。找到activemq/conf/activemq.xml, 并打开在 <broker> 节点中，在 <systemusage> 节点上面，增加如下的一个插件</systemusage></broker></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;simpleAuthenticationPlugin&gt;</span><br><span class="line">        &lt;users&gt;</span><br><span class="line">           &lt;authenticationUser username=&quot;$&#123;activemq.username&#125;&quot; password=&quot;$&#123;activemq.password&#125;&quot; groups=&quot;users,admins&quot;/&gt;</span><br><span class="line">        &lt;/users&gt;</span><br><span class="line">    &lt;/simpleAuthenticationPlugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>这样就开启了密码认证<br>然后账号密码的配置在 activemq/conf/credentials.properties 文件中</p><p>打开这个文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## ---------------------------------------------------------------------------</span><br><span class="line">## Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">## contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">## this work for additional information regarding copyright ownership.</span><br><span class="line">## The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">## (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line">## the License.  You may obtain a copy of the License at</span><br><span class="line">## </span><br><span class="line">## http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">## </span><br><span class="line">## Unless required by applicable law or agreed to in writing, software</span><br><span class="line">## distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">## See the License for the specific language governing permissions and</span><br><span class="line">## limitations under the License.</span><br><span class="line">## ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Defines credentials that will be used by components (like web console) to access the broker</span><br><span class="line"></span><br><span class="line"># 账号</span><br><span class="line">activemq.username=system</span><br><span class="line"># 密码</span><br><span class="line">activemq.password=manager</span><br><span class="line">guest.password=password</span><br></pre></td></tr></table></figure></p><p>这样就配置完毕了。</p><hr><p><strong>创建过程中的注意点</strong><br>session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</p><ul><li>Boolean.FALSE 表示本次会话不开启事务管理，假如需要开启事务管理，将其改为 Boolean.TRUE，同时需要在发送消息后添加 session.commit()，否则，消息是不会被提交的</li><li>Session.AUTO_ACKNOWLEDGE 表示消息确认机制<br>AUTO_ACKNOWLEDGE：自动确认<br>CLIENT_ACKNOWLEDGE：客户端确认<br>SESSION_TRANSACTED：事务确认，如果使用事务推荐使用该确认机制<br>DUPS_OK_ACKNOWLEDGE：懒散式确认，消息偶尔不会被确认，也就是消息可能会被重复发送，但发生的概率很小</li></ul><hr><h3 id="使用-Spring-集成-JMS-连接-ActiveMQ"><a href="#使用-Spring-集成-JMS-连接-ActiveMQ" class="headerlink" title="使用 Spring 集成 JMS 连接 ActiveMQ"></a>使用 Spring 集成 JMS 连接 ActiveMQ</h3><ul><li>CollectionFactory 用于管理连接的连接工厂<ul><li>一个 Spring 为我们提供的连接池</li><li>JmsTemplate 每次发消息都会重新创建连接，会话和 producer</li><li>Spring 中提供了 SingleConnectionFactory 和 CachingConnectionFactory</li></ul></li><li>JmsTemplate 用于发送和接收消息的模板类<ul><li>是 Spring 提供的，只需向 Spring 容器内注册这个类就可以使用 JmsTemplate 方便的操作 jms</li><li>JmsTemplate 类是线程安全的，可以在整个应用范围使用。</li></ul></li><li>MessageListener 消息监听器<ul><li>实现一个 onMessage 方法，该方法只接收一个 Message 参数</li></ul></li></ul><hr><h3 id="为什么要对消息中间件集群"><a href="#为什么要对消息中间件集群" class="headerlink" title="为什么要对消息中间件集群"></a>为什么要对消息中间件集群</h3><ul><li>实现高可用，以单点故障引起的服务中断</li><li>实现负载均衡，以提升效率为更多客户提供服务</li></ul><h4 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h4><ul><li>客户端集群：让多个消费者消费同一个队列</li><li>Broker clusters：多个 Broker 之间同步消息</li><li>Master Slave：实现高可用</li></ul><h4 id="客户段配置"><a href="#客户段配置" class="headerlink" title="客户段配置"></a>客户段配置</h4><p>ActiveMQ 失效转移（failover）<br>允许当其中一台消息服务器宕机时，客户端在传输层上重新连接到其它消息服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：failover : (uri1,...,uriN) ? transportOptions</span><br></pre></td></tr></table></figure></p><p>transportOptions 参数说明</p><ul><li>randomize 默认为 true，表示在 URI 列表中选择 URI 连接时是否采用随机策略</li><li>initialReconnectDelay 默认为10，单位毫秒，表示第一次尝试重连之间等待的时间</li><li>maxReconnectDelay 默认30000，单位毫秒，最长重连的时间间隔</li></ul><h4 id="Broker-Cluster-集群配置"><a href="#Broker-Cluster-集群配置" class="headerlink" title="Broker Cluster 集群配置"></a>Broker Cluster 集群配置</h4><p>原理<br><img src="/images/pasted-14.png" alt="图六"></p><h4 id="NetworkConnector（网络连接器）"><a href="#NetworkConnector（网络连接器）" class="headerlink" title="NetworkConnector（网络连接器）"></a>NetworkConnector（网络连接器）</h4><p>&emsp;&emsp;网络连接器主要用于配置 ActiveMQ 服务器与服务器之间的网络通讯方式，用于服务器透传消息。<br>&emsp;&emsp;网络连接器分为静态连接器和动态连接器。</p><ul><li><p>静态连接器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector uri=&quot;static:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)&quot;/&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态连接器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt;</span><br><span class="line">    &lt;networkConnector uri=&quot;multicast://default&quot;/&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br><span class="line"></span><br><span class="line">&lt;transportConnectors&gt;</span><br><span class="line">    &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Master-Slave-集群配置"><a href="#Master-Slave-集群配置" class="headerlink" title="Master/Slave 集群配置"></a>Master/Slave 集群配置</h4><p>ActiveMQ Master Slave 集群方案</p><ul><li>Share nothing storage master/slave（已过时，5.8+后移除）</li><li>Shared storage master/slave 共享存储</li><li>Replicated LevelDB Store 基于复制的 LevelDB Store</li></ul><p>共享存储集群的原理<br><img src="/images/pasted-16.png" alt="图七"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ActiveMQ 官方网址：&lt;a href=&quot;http://activemq.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://activemq.apache.org&lt;/a&gt;&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="MQ" scheme="https://zhangshengjian.github.io/categories/MQ/"/>
    
    
      <category term="ActiveMQ" scheme="https://zhangshengjian.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>锁汇总</title>
    <link href="https://zhangshengjian.github.io/2019/06/02/%E9%94%81%E6%B1%87%E6%80%BB/"/>
    <id>https://zhangshengjian.github.io/2019/06/02/锁汇总/</id>
    <published>2019-06-02T14:19:56.000Z</published>
    <updated>2019-06-03T13:32:39.593Z</updated>
    
    <content type="html"><![CDATA[<p><b>乐观锁</b></p><p>分为三个阶段：数据读取、写入校验、数据写入。</p><p>假设数据一般情况下不会造成冲突，只有在数据进行提交更新时，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息，让用户决定如何去做。fail-fast 机制。</p><p><b>悲观锁</b></p><p>正如其名，它指对数据被外界（可能是本机的其他事务，也可能是来自其它服务器的事务处理）的修改持保守态度。在整个数据处理过程中，将数据处于锁定状态。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受。</p><p><b>分布式锁</b></p><p>分布式集群中，对锁接口 QPS 性能要求很高，单台服务器满足不了要求，可以考虑将锁服务部署在独立的分布式系统中，比如借助分布式缓存来实现。</p><p><b>可重入锁</b></p><p>可重入锁，也叫做递归锁，是指在同一个线程在调外层方法获取锁的时候，再进入内层方法会自动获取锁。ReentrantLock 和 synchronized 都是可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><p><b>自旋锁</b></p><p>自旋锁是采用让当前线程不停地在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。</p><p>自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不断增加时，性能下降明显，因为每个线程都需要执行，会占用 CPU 时间片。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p><p><b>独享锁</b></p><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>ReentrantLock、Synchronized 都是独享锁。</p><p><b>共享锁</b></p><p>共享锁是指该锁可被多个线程所持有。ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的。独享锁与共享锁也是通过AQS（AbstractQueuedSynchronizer）来实现的，通过实现不同的方法，来实现独享或者共享。</p><p><b>互斥锁</b></p><p>独享锁/共享锁就是一种广义的说法，互斥锁/读写锁指具体的实现。</p><p>互斥锁在 Java 中的具体实现就是 ReentrantLock。</p><p><b>读写锁</b></p><p>读写锁在 Java 中的具体实现就是 ReentrantReadWriteLock。</p><p><b>阻塞锁</b></p><p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。</p><p>JAVA 中，能够进入/退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()/notify()，LockSupport.park()/unpark()。</p><p><b>公平锁</b></p><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><p><b>非公平锁</b></p><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</p><p>可能造成优先级反转或者饥饿现象。对于Java ReentrantLock 而言，通过构造函数 ReentrantLock(boolean fair) 指定该锁是否是公平锁，默认是非公平锁。</p><p>非公平锁的优点在于吞吐量比公平锁大。对于 Synchronized 而言，也是一种非公平锁。</p><p><b>分段锁</b></p><p>分段锁其实是一种锁的设计，目的是细化锁的粒度，并不是具体的一种锁，对于 ConcurrentHashMap 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap（JDK7 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment 继承了 ReentrantLock)。</p><p>当需要 put 元素的时候，并不是对整个 HashMap 加锁，而是先通过 hashcode 知道要放在哪一个分段中，然后对这个分段加锁，所以当多线程 put 时，只要不是放在同一个分段中，可支持并行插入。</p><p><b>对象锁</b></p><p>一个线程可以多次对同一个对象上锁。对于每一个对象，Java 虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。</p><p>在 Java 程序中，只需要使用 synchronized 块或者 synchronized 方法就可以标志一个监视区域。当每次进入一个监视区域时，Java 虚拟机都会自动锁上对象或者类。</p><p>synchronized 修饰非静态方法、同步代码块的 synchronized (this)、synchronized (非 this 对象)，锁的是对象，线程想要执行对应同步代码，需要获得对象锁。</p><p><b>类锁</b></p><p>synchronized 修饰静态方法或者同步代码块的 synchronized (类 .class)，线程想要执行对应同步代码，需要获得类锁。</p><p><b>信号量</b></p><p>Semaphore 是用来保护一个或者多个共享资源的访问，Semaphore 内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p><p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p><b>条件变量 Condition</b></p><p>条件变量很大一个程度上是为了解决 Object.wait/notify/notifyAll 难以使用的问题。</p><p>有人会问，如果一个线程 lock() 后被挂起还没有执行 unlock()，那么另外一个线程就拿不到锁，那么就无法唤醒前一个线程 signal()，这样岂不是“死锁”了？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解释：</span><br><span class="line">进入 lock.lock() 后唯一可能释放锁的操作就是 await()。也就是说 await() 操作实际上就是释放锁，然后挂起线程，一旦条件满足就被唤醒，再次获取锁！</span><br></pre></td></tr></table></figure></p><p><b>行级锁</b></p><p>行级锁是数据库引擎中对记录更新的时候引擎本身上的锁，是数据库引擎的一部分，在数据库引擎更新一条数据的时候，本身就会对记录上锁，这时候即使有多个请求更新，也不会产生脏数据，行级锁的粒度非常细，上锁的时间窗口也最少，只有更新数据记录的那一刻，才会对记录上锁，因此，能大大减少数据库操作的冲突，发生锁冲突的概率最低，并发度也最高。</p><p>通常在扣减库存的场景下使用行级锁，这样可以通过数据库引擎本身对记录加锁的控制，保证数据库的更新的安全性，并且通过 where 语句的条件，保证库存不会被减到0以下，也就是能够有效的控制超卖的场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update ... set amount = amount - 1 where id = $id and amount - 1 &gt;= 0</span><br></pre></td></tr></table></figure></p><p>另外一种场景是在状态转换的时候使用行级锁，例如交易引擎中，状态只能从 init 流转到 doing 状态，任何重复的从 init 到 doing 的流转，或者从 init 到 finished 等其他状态的流转都会失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean result = executeSql(&quot;update ... set status = &apos;doing&apos; where id = $id and status = &apos;init&apos;&quot;); </span><br><span class="line">if (result) </span><br><span class="line">&#123;   // process sucessful logic &#125; </span><br><span class="line">else </span><br><span class="line">&#123;   // process failure logic &#125;</span><br></pre></td></tr></table></figure></p><p>行级锁的并发性较高，性能是最好的，适用于高并发下扣减库存和控制状态流转的方向的场景。</p><p>但是，有人说这种方法是不能保证幂等的，比如说，在扣减余额场景，多次提交可能会扣减多次，这确实是实际存在的，但是，我们是有应对方案的，我们可以记录扣减的操作日志，如果有非幂等的场景出现，通过比较操作记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean result = executeSql(&quot;update ... set amount = amount - 1 where id = $id and amount &gt; 1&quot;); </span><br><span class="line">if (result) </span><br><span class="line">&#123;    executeSql(&quot;insert into hist (pre_amout, post_amout) values ($amount, $amount -1)&quot;);    </span><br><span class="line">// process successful logic </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // process failure logic </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在支付平台架构设计中，通常对交易和支付系统的流水表的状态流转的控制、对账户系统的状态控制，分账和退款余额的更新等，都推荐使用行级锁，而单独使用乐观锁和悲观锁是不推荐的。</p><p><b>其它</b></p><p>Synchronized：非公平，悲观，独享，互斥，可重入的重量级锁。<br>ReentrantLock：默认非公平但可实现公平的(构造器传 true)，悲观，独享，互斥，可重入，重量级锁。<br>ReentrantReadWriteLocK：默认非公平但可实现公平的(构造器传 true)，悲观，写独享，读共享，读写，可重入，重量级锁。</p><p>线程 A 和 B 都要获取对象 o 的锁定，假设 A 获取了对象 o 锁，B 将等待 A 释放对 o 的锁定</p><ul><li>synchronized ，如果 A 不释放，B 将一直等下去，不能被中断；</li><li>ReentrantLock，如果 A 不释放，可以使 B 在等待了足够长的时间以后，中断等待，而干别的事情；</li></ul><p>ReentrantLock获取锁定有三种方式：</p><ul><li>lock()， 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁；</li><li>tryLock()， 如果获取了锁立即返回 true，如果别的线程正持有锁，立即返回 false；</li><li>tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回 true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回 true，如果等待超时，返回 false；</li><li>lockInterruptibly()，如果获取了锁定立即返回，如果没有获取锁，当前线程处于休眠状态，直到获取锁定，或者当前线程被别的线程中断；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;乐观锁&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;分为三个阶段：数据读取、写入校验、数据写入。&lt;/p&gt;
&lt;p&gt;假设数据一般情况下不会造成冲突，只有在数据进行提交更新时，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息，让用户决定如何去做。fail-fast 机制。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Lock" scheme="https://zhangshengjian.github.io/categories/Lock/"/>
    
    
      <category term="Lock" scheme="https://zhangshengjian.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>SQL for update</title>
    <link href="https://zhangshengjian.github.io/2019/05/29/SQL-for-update/"/>
    <id>https://zhangshengjian.github.io/2019/05/29/SQL-for-update/</id>
    <published>2019-05-29T13:59:38.000Z</published>
    <updated>2019-06-02T13:43:27.827Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Oracle 行级共享锁</p></blockquote><p>行级共享锁通常是 SELECT … FROM FOR UPDATE 语句来添加的，该方法也是手工锁定某些记录的主要方法，比如，当我们在查询某些记录的过程中，不希望其他用户对查询的记录进行更新操作，则可以发出这样的语句。当数据使用完毕以后，直接发出 ROLLBACK 命令将锁定解除（如果我们查询到了并且修改了，则 COMMIT 后就可以释放锁）。</p><p><b>SELECT … FOR UPDATE</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM goods WHERE goods_code =&apos;001&apos; FOR UPDATE;</span><br></pre></td></tr></table></figure></p><p>当 SELECT 语句中使用了 FOR UPDATE，如果当前 SELECT 发现自己的结果集中有一条或者多条数据正在被修改，例如有其他的语句提前 FOR UPDATE，那么再执行此语句就会一直等待；</p><p>此时执行：<br>UPDATE/DELETE 等语句都出现等待。只有对应的占用锁的数据被提交 COMMIT（或者 ROLLBACK）时才可以进行新的 FOR UPDATE 上锁或者进行 UPDATE/DELETE。</p><p><b>SELECT … FOR UPDATE NOWAIT</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM goods WHERE goods_code =&apos;001&apos; FOR UPDATE NOWAIT;</span><br></pre></td></tr></table></figure></p><p>FOR UPDATE NOWAIT 和 FOR UPDATE 都会对查询到的当前结果集进行加锁。区别是 FOR UPDATE NOWAIT 发现自己要加锁的结果集正在被其他操作修改（已经被加锁），则直接反馈资源占用，不会像 FOR UPDATE 一样等待执行。</p><p><b>SELECT … FOR UPDATE WAIT</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM goods WHERE goods_code =&apos;001&apos; FOR UPDATE WAIT;</span><br></pre></td></tr></table></figure></p><p>与 FOR UPDATE NOWAIT 的区别是 FOR UPDATE WAIT 可配置等待时间，单位秒。当过了这个时间，被加锁资源还未被释放，则和 FOR UPDATE NOWAIT 一样直接反馈资源占用，否则执行此语句。</p><p><b>SELECT … FOR UPDATE SKIP LOCKED</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM goods FOR UPDATE SKIP LOCKED;</span><br></pre></td></tr></table></figure></p><p>跳过加锁行，对满足条件的其他行进行加锁。</p><p><b>SELECT … INNER JOIN … FOR UPDATE</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stat_dic_goods sg INNER JOIN goods g ON sg.goods_code = g.goods_code WHERE sg.goods_code = &apos;001&apos; FOR UPDATE;</span><br></pre></td></tr></table></figure></p><p>关联的表都加锁。</p><p><b>SELECT … INNER JOIN … FOR UPDATE OF …</b></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM stat_dic_goods sg INNER JOIN goods g ON sg.goods_code = g.goods_code WHERE sg.goods_code = &apos;001&apos; FOR UPDATE OF sg.goods_code;</span><br></pre></td></tr></table></figure></p><p>对关联的表中的某一张表进行加锁。</p><hr><blockquote><p>Oracle 共享锁</p></blockquote><p><b>LOCK TABLE stat_dic_goods IN SHARE MODE</b><br>执行完 lock 语句再执行 update 语句就会出现等待中，因为 lock 语句已经将这个表锁了，此时只允许读取不允许修改。通过 lock table in share mode 命令添加该S锁。在该锁定模式下，不允许任何用户更新表。但是允许其他用户发出 select … from for update 命令对表添加 RS 锁。Oracle 只有表级别的共享锁没有行级别的共享锁，行级别的是排他锁，多个用户可以同时对同一个表加共享锁。</p><hr><blockquote><p>Oracle 排他锁</p></blockquote><p><b>LOCK TABLE stat_dic_goods IN EXCLUSIVE MODE</b><br>同一张表不能同时执行共享锁和排他锁。通过 lock table in exclusive mode 命令添加 X 锁。在该锁定模式下，其他用户不能对表进行任何的 DML 和 DDL 操作，该表上只能进行查询。</p><hr><blockquote><p>Oracle 行级排他锁</p></blockquote><p><b>LOCK TABLE stat_dic_goods IN ROW EXCLUSIVE MODE</b><br>当我们进行 DML 时会自动在被更新的表上添加 RX 锁，或者也可以通过执行 lock 命令显式的在表上添加RX 锁。在该锁定模式下，允许其他的事务通过 DML 语句修改相同表里的其他数据行，或通过 lock 命令对相同表添加 RX 锁定，但是不允许其他事务对相同的表添加排他锁（X 锁）。</p><hr><blockquote><p>Oracle 共享行级排他锁</p></blockquote><p><b>LOCK TABLE stat_dic_goods IN SHARE ROW EXCLUSIVE MODE</b><br>通过 lock table in share row exclusive mode 命令添加 SRX 锁。该锁定模式比行级排他锁和共享锁的级别都要高，这时不能对相同的表进行DML操作，也不能添加共享锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Oracle 行级共享锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;行级共享锁通常是 SELECT … FROM FOR UPDATE 语句来添加的，该方法也是手工锁定某些记录的主要方法，比如，当我们在查询某些记录的过程中，不希望其他用户对查询的记
      
    
    </summary>
    
      <category term="SQL" scheme="https://zhangshengjian.github.io/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://zhangshengjian.github.io/tags/SQL/"/>
    
      <category term="FOR UPDATE" scheme="https://zhangshengjian.github.io/tags/FOR-UPDATE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 常用命令</title>
    <link href="https://zhangshengjian.github.io/2019/05/24/MySQL-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangshengjian.github.io/2019/05/24/MySQL-常用命令/</id>
    <published>2019-05-24T13:45:50.000Z</published>
    <updated>2019-05-24T13:49:09.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>常用 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>mysql -u root -p -P port</td><td>登录 MySQL 数据库</td></tr><tr><td>mysql -h ip_address -P 3306 -u root -p123456</td><td>远程登录数据库（端口”3306”，用户名为 “root”，密码”123456”）</td></tr><tr><td>show databases</td><td>查看数据库</td></tr><tr><td>use database_name</td><td>使用数据库</td></tr><tr><td>show tables</td><td>查看都有哪些表</td></tr><tr><td>desc table_name</td><td>查看表结构</td></tr><tr><td>drop table table_name</td><td>删除表</td></tr><tr><td>drop database database_name</td><td>删除数据库</td></tr><tr><td>show create table table_name</td><td>显示建表语句</td></tr><tr><td>show create schema database_name</td><td>显示创建数据库语句</td></tr><tr><td>create schema <code>new_schema</code> default character set utf8;</td><td>创建数据库</td></tr></tbody></table><blockquote><p>数据导入导出 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>source db.sql</td><td>执行 .sql 脚本</td></tr><tr><td>mysqldump -h host -uroot -p database_name &gt; dump.sql</td><td>dump 整个数据库的表结构和数据</td></tr><tr><td>mysqldump -h host -uroot -p database_name table_name &gt; dump.sql</td><td>dump 单个数据库表结构和数据</td></tr><tr><td>mysqldump -h host -uroot -p  -d database_name &gt; dump.sql</td><td>dump 整个数据库的表结构</td></tr><tr><td>mysqldump -h host -uroot -p -d database_name table_name &gt; dump.sql</td><td>dump 单个数据库表结构</td></tr><tr><td>mysqldump -h host -uroot -p -t database_name &gt; dump.sql</td><td>dump 整个数据库的数据，不添加 create table</td></tr><tr><td>mysql -uuser_name -ppassword -hhost -P3306 -D db_name –default-character-set=utf8 -e “select * from custom where com_uid = ‘001’” &gt; test.csv</td><td>将数据库中的数据导出到 excel 文件中 user_name = 数据库用户名 password = 数据库密码 host = 主机名称 db_name = 数据库名称</td></tr><tr><td>mysqldump -uuser_name -ppassword -hhost -P 3306 db_name table_name –where=”com_uid=’001’” &gt; /Users/dump.sql</td><td>将数据库中的数据 dump 到 sql 文件中 user_name = 数据库用户名 password = 数据库密码 host = 主机名称 db_name = 数据库名称 table_name = 表名</td></tr></tbody></table><blockquote><p>索引 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>show index from table_name</td><td>查看表索引</td></tr><tr><td>repair table table_name quick</td><td>重建索引命令</td></tr><tr><td>alter table table_name add index index_name (column list)</td><td>创建联合索引</td></tr><tr><td>alter table table_name add unique index_name (column list)</td><td>创建普通索引</td></tr><tr><td>alter table table_name add primary key index_name (column list)</td><td>创建主键索引</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;常用 命令篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mysql -u root -p -P po
      
    
    </summary>
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>消息队列简介</title>
    <link href="https://zhangshengjian.github.io/2019/05/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/"/>
    <id>https://zhangshengjian.github.io/2019/05/22/消息队列简介/</id>
    <published>2019-05-22T10:45:50.000Z</published>
    <updated>2019-06-10T11:31:34.730Z</updated>
    
    <content type="html"><![CDATA[<p><b>为什么使用消息队列</b><br>消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有3个：<b>解耦、异步、削峰</b>。</p><p><b>解耦</b><br>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……<br><img src="/images/pasted-4.png" alt="图一"><br>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="/images/pasted-3.png" alt="图二"><br><b>总结</b>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。<br>需要考虑一下负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，就需要去考虑在项目里，是不是可以运用这个 MQ 去进行系统的解耦。</p><p><b>异步</b><br>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><p><img src="/images/pasted-5.png" alt="图三"><br>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p><p><img src="/images/pasted-6.png" alt="图四"></p><p><b>削峰</b><br>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img src="/images/pasted-7.png" alt="图五"><br>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img src="/images/pasted-8.png" alt="图六"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><hr><p><b>消息队列有什么优缺点</b></p><p><b>优点</b></p><ul><li>解耦</li><li>异步</li><li>削峰</li><li>横向扩展</li><li>安全可靠</li><li>顺序保证（例如 Kafka）</li><li>更多。。。</li></ul><p><b>缺点</b></p><ul><li><p>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉。本来就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，不就完了？如何保证消息队列的高可用，可以点击这里查看。</p></li><li><p>系统复杂度提高<br>硬生生加个 MQ 进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p></li><li><p>一致性问题<br>A 系统处理完了直接返回成功了，人都以为这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？这数据就不一致了。</p></li></ul><p>所以消息队列实际是一种非常复杂的架构，引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><hr><p><b>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</b></p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<b>中小型公司</b>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<b>大型公司</b>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<b>大数据领域</b>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;为什么使用消息队列&lt;/b&gt;&lt;br&gt;消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有3个：&lt;b&gt;解耦、异步、削峰&lt;/b&gt;。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;解耦&lt;/b&gt;&lt;br&gt;看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据
      
    
    </summary>
    
      <category term="MQ" scheme="https://zhangshengjian.github.io/categories/MQ/"/>
    
    
      <category term="Kafka" scheme="https://zhangshengjian.github.io/tags/Kafka/"/>
    
      <category term="RabbitMQ" scheme="https://zhangshengjian.github.io/tags/RabbitMQ/"/>
    
      <category term="ActiveMQ" scheme="https://zhangshengjian.github.io/tags/ActiveMQ/"/>
    
      <category term="MQ" scheme="https://zhangshengjian.github.io/tags/MQ/"/>
    
      <category term="RocketMQ" scheme="https://zhangshengjian.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://zhangshengjian.github.io/2019/05/20/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangshengjian.github.io/2019/05/20/Linux-常用命令/</id>
    <published>2019-05-20T15:00:15.000Z</published>
    <updated>2019-05-21T10:48:49.233Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux 命令概览</p></blockquote><p><img src="/images/pasted-0.png" alt="Linux 命令概览"></p><blockquote><p>vi 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>:q</td><td>不保存文件，退出 vi 模式</td></tr><tr><td>:wq</td><td>保存文件并退出 vi 模式</td></tr><tr><td>:w</td><td>保存文件但不退出 vi 模式</td></tr><tr><td>:w!</td><td>强制保存文件并不退出 vi 模式</td></tr><tr><td>:wq!</td><td>强制保存文件并退出 vi 模式</td></tr><tr><td>:w file</td><td>修改保存到 file 中并不退出 vi 模式</td></tr><tr><td>:q!</td><td>不保存文件并强制退出 vi 模式</td></tr><tr><td>:e!</td><td>放弃所有修改并从上次保存文件开始再编辑</td></tr><tr><td>GG == shift + g</td><td>编辑光标跳转到最后一行</td></tr><tr><td>gg</td><td>编辑光标跳转到首行</td></tr><tr><td>shift + 6 =&gt; ^</td><td>光标移到行首</td></tr><tr><td>shift + 4 =&gt; $</td><td>光标移到行尾</td></tr><tr><td>DD</td><td>删除当前行</td></tr><tr><td>dG</td><td>删除当前光标后面的全部内容</td></tr><tr><td>sudo -u root vi /etc/profile</td><td>以管理员模式强制编辑文件</td></tr></tbody></table><blockquote><p>tar 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>tar -czf demo.tar.gz <em>.</em></td><td>压缩文件</td></tr><tr><td>tar -zvcf demo.tar.gz <em>.</em></td><td>压缩文件</td></tr><tr><td>tar -zxvf demo.tar.gz</td><td>解压文件</td></tr><tr><td>tar -zxvpf demo.tar.gz</td><td>解压文件为 .tar.gz</td></tr><tr><td>tar -jxvpf demo.tar.bz2</td><td>解压文件为 .tar.bz2</td></tr></tbody></table><blockquote><p>du 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>du -h</td><td>查看内存使用情况</td></tr><tr><td>du -sh .</td><td>对当前目录下所有的目录和文件的大小进行汇总, -s 表示汇总, -h 表示以 KB, MB, GB, TB 格式进行人性化显示</td></tr><tr><td>du -sh *</td><td>对当前目录下每一个目录和文件的大小分别进行汇总</td></tr><tr><td>du -sh apps</td><td>对指定的目录的大小进行汇总</td></tr><tr><td>du -sh * &#124; grep [M]</td><td>对当前目录下所有的目录和文件分别进行汇总,并使用 “grep [M]” 筛选出所有大小为 M(兆) 级别的目录和文件</td></tr><tr><td>du -sh * &#124; grep [G]</td><td>筛选出大小为 GB 级别的目录和文件</td></tr><tr><td>du -sh * &#124; grep [MG]</td><td>筛选出大小为 MB 和 GB 级别的目录和文件</td></tr><tr><td>du -sh * &#124; grep [MG] &#124; sort -nr</td><td>筛选出大小为 MB 和 GB 级别的目录和文件，并降序排序</td></tr></tbody></table><blockquote><p>ls 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>ls -lR &#124; grep “^-“ &#124; wc -l</td><td>统计当前文件夹下文件的个数，包括子文件夹里的</td></tr><tr><td>ls -lR &#124; grep “^d” &#124; wc -l</td><td>统计文件夹下目录的个数，包括子文件夹里的</td></tr><tr><td>ls -l &#124; grep “^-“ &#124; wc -l</td><td>统计当前文件夹下文件的个数</td></tr><tr><td>ls -l &#124; grep “^d” &#124; wc -l</td><td>统计当前文件夹下目录的个数</td></tr><tr><td>ls -ah</td><td>查看当前目录文件，包含隐藏文件</td></tr></tbody></table><blockquote><p>find 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>find . -name “*.war”</td><td>查找目录下以 .war 结尾的相关文件</td></tr><tr><td>find . -name “config.xml”</td><td>查找目录下的 config.xml 文件</td></tr></tbody></table><blockquote><p>其他常用 命令篇</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>scp root@ip_address:/home/demo.tar.gz demo.tar.gz</td><td>服务器传输文件</td></tr><tr><td>ps -fC java</td><td>查看进程详细信息</td></tr><tr><td>ll -t</td><td>按时间顺序列出文件</td></tr><tr><td>ll &#124; grep .sql -c</td><td>查看以某个后缀名结尾的文件个数</td></tr><tr><td>uname -a 或者 cat /proc/version</td><td>查看系统内核版本号及系统名称</td></tr><tr><td>which java</td><td>查看 jdk 路径</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux 命令概览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-0.png&quot; alt=&quot;Linux 命令概览&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vi 命令篇&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhangshengjian.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhangshengjian.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
