<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>坚持到放弃</title>
  
  <subtitle>make one more step.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangshengjian.github.io/"/>
  <updated>2019-09-29T14:58:48.404Z</updated>
  <id>https://zhangshengjian.github.io/</id>
  
  <author>
    <name>张 胜 健 的 博 客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 查询语句总结</title>
    <link href="https://zhangshengjian.github.io/2019/09/29/MySQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangshengjian.github.io/2019/09/29/MySQL-查询语句总结/</id>
    <published>2019-09-29T14:35:00.000Z</published>
    <updated>2019-09-29T14:58:48.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><h4 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h4><p><em>注意：业务代码中一般不会这样使用，会写上所有的列名进行查询</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><h4 id="查询指定的字段"><a href="#查询指定的字段" class="headerlink" title="查询指定的字段"></a>查询指定的字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;column1_name&gt;,&lt;columns_name&gt;,... FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><h4 id="查询带有表别名"><a href="#查询带有表别名" class="headerlink" title="查询带有表别名"></a>查询带有表别名</h4><p><em>注意：1.别名中如果有特殊符号或空格，需要用引号引起来；2.AS 可省略</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt; [AS] &lt;alias_name&gt;;</span><br></pre></td></tr></table></figure><h4 id="查询带有列别名"><a href="#查询带有列别名" class="headerlink" title="查询带有列别名"></a>查询带有列别名</h4><p><em>注意：AS 可省略</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;column_name1&gt; [AS] &lt;alias_name1&gt;, &lt;column_name2&gt; [AS] &lt;alias_name2&gt; ... FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><h4 id="查询去掉重复值"><a href="#查询去掉重复值" class="headerlink" title="查询去掉重复值"></a>查询去掉重复值</h4><p><em>注意：如果有多个字段，需要同时重复</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT &lt;column_name1&gt;,&lt;column_name2&gt;, ... FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><h4 id="运算查询"><a href="#运算查询" class="headerlink" title="运算查询"></a>运算查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (&lt;column1_name&gt; + &lt;column2_name&gt;) FROM &lt;table_name&gt;;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">大于 &gt;</span><br><span class="line">小于 &lt;</span><br><span class="line">等于 =</span><br><span class="line">大于等于 &gt;=</span><br><span class="line">小于等于 &lt;=</span><br><span class="line">不等于 &lt;&gt;(!=)</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">between…and… : 显示在某一区间的值(含头含尾)</span><br><span class="line">in(多个条件) : 或者(or)关系</span><br><span class="line">like: 模糊查询</span><br><span class="line">% 代表零个或者多个任意字符.</span><br><span class="line">_ 代表一个字符.</span><br><span class="line">is null : 判断是否为空</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><em>注意：1.不写的话默认为升序 ASC；2.被排序的字段如果有多个，先按照第一个排序，再按照后边的依次排序；3.写在 sql 语句末尾</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;table_name&gt; ORDER BY &lt;column1_name&gt; ASC(升序)/DESC(降序);</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><em>注意：select 之后 , from 之前</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(求和) : 指定列不是数值类型，计算结果为 0;</span><br><span class="line">count(统计数) : 不包含 null; 一般用 *;</span><br><span class="line">max(最大值) : 如果是字符串类型，使用字符串排序;</span><br><span class="line">min(最小值) : 如果是字符串类型，使用字符串排序;</span><br><span class="line">avg(平均值) : 指定列不是数值类型，计算结果为 0;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><em>注意：被分组的字段,一般都写在  select 后作为查询条件 , 方便查看</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group by 被分组的字段 [having 条件]</span><br><span class="line">where : 分组查询前过滤</span><br><span class="line">having : 分组查询后过滤</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><em>注意：数据库中行的索引是从0开始，列的索引是从1开始</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用关键字 LIMIT</span><br><span class="line">格式一: 只要前 x 条数据</span><br><span class="line">SELECT * FROM &lt;table_name&gt; LIMIT x;</span><br><span class="line"></span><br><span class="line">格式二: 分页查询</span><br><span class="line">SELECT * FROM &lt;table_name&gt; LIMIT m, n;</span><br><span class="line">m : 每页数据的开始行数（变化的）</span><br><span class="line">n : 每页显示的数量（固定的）</span><br></pre></td></tr></table></figure><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><p>从表使用主表的主键作为主键（外键）<br><em>注意：1.主表中有的数据 , 从表中可以没有；2.主表必须有数据, 才能向从表中添加数据；3.删除主表的数据 , 要先删除从表之后 , 才能删除主表</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单表查询&quot;&gt;&lt;a href=&quot;#单表查询&quot; class=&quot;headerlink&quot; title=&quot;单表查询&quot;&gt;&lt;/a&gt;单表查询&lt;/h2&gt;&lt;h3 id=&quot;简单查询&quot;&gt;&lt;a href=&quot;#简单查询&quot; class=&quot;headerlink&quot; title=&quot;简单查询&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Gradle 命令</title>
    <link href="https://zhangshengjian.github.io/2019/09/20/Gradle-%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangshengjian.github.io/2019/09/20/Gradle-命令/</id>
    <published>2019-09-20T12:56:00.000Z</published>
    <updated>2019-09-20T13:04:41.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Gradle 常用命令</p></blockquote><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>gradle -v</td><td>版本号</td></tr><tr><td>gradle clean</td><td>清除 build 文件夹</td></tr><tr><td>gradle build</td><td>检查依赖并打包</td></tr><tr><td>gradle assembleDebug</td><td>编译打包 Debug 包</td></tr><tr><td>gradle assembleRelease</td><td>编译打包 Release 包</td></tr><tr><td>gradle installRelease</td><td>打包并安装 Release 包</td></tr><tr><td>gradle unstallRelease</td><td>卸载 Release 包</td></tr><tr><td>gradle dependencies</td><td>查看依赖图表</td></tr><tr><td>gradle clean build -x test</td><td>跳过测试编译</td></tr><tr><td>gradle –profile build</td><td>分析构建任务</td></tr><tr><td>gradle build –dry-run</td><td>编译并不执行任务</td></tr><tr><td>gradle install</td><td>安置项目 jar 包到本地 Maven 仓库</td></tr><tr><td>gradle tasks</td><td>查看 Gradle 任务</td></tr><tr><td>gradle tasks –all</td><td>查看所有 Gradle 任务</td></tr><tr><td>gradle build –daemon</td><td>使用 Gradle 守护程序(Daemon)</td></tr><tr><td>gradle build –offline</td><td>用离线模式运行</td></tr><tr><td>gradle clean build –refresh-dependencies</td><td>刷新 Gradle 依赖缓存</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Gradle 常用命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;gradle -v&lt;/td&gt;
&lt;t
      
    
    </summary>
    
      <category term="Gradle" scheme="https://zhangshengjian.github.io/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="https://zhangshengjian.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>SVN 使用问题记录</title>
    <link href="https://zhangshengjian.github.io/2019/09/19/SVN/"/>
    <id>https://zhangshengjian.github.io/2019/09/19/SVN/</id>
    <published>2019-09-19T00:22:00.000Z</published>
    <updated>2019-09-19T00:27:03.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新代码提示需要-cleanup"><a href="#更新代码提示需要-cleanup" class="headerlink" title="更新代码提示需要 cleanup"></a>更新代码提示需要 cleanup</h3><h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><p><img src="/images/pasted-64.png" alt="图一"></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>直接在 IDEA 的 Terminal 中执行如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn cleanup</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;更新代码提示需要-cleanup&quot;&gt;&lt;a href=&quot;#更新代码提示需要-cleanup&quot; class=&quot;headerlink&quot; title=&quot;更新代码提示需要 cleanup&quot;&gt;&lt;/a&gt;更新代码提示需要 cleanup&lt;/h3&gt;&lt;h4 id=&quot;问题现象&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="SVN" scheme="https://zhangshengjian.github.io/categories/SVN/"/>
    
    
      <category term="SVN" scheme="https://zhangshengjian.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 Stream</title>
    <link href="https://zhangshengjian.github.io/2019/09/05/Java-8-Stream/"/>
    <id>https://zhangshengjian.github.io/2019/09/05/Java-8-Stream/</id>
    <published>2019-09-05T12:56:00.000Z</published>
    <updated>2019-09-05T12:58:09.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作。<br>在 Java 中，集合和数组是我们经常会用到的数据结构，但是在 Java 8 之前，集合和数组的处理并不是很便捷，<br>这一问题在 Java 8 中得到了改善，Java 8 API 添加了一个新的抽象称为流 Stream。<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>Stream API 可以极大提高 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作（terminal operation）</p><h3 id="Stream-的创建"><a href="#Stream-的创建" class="headerlink" title="Stream 的创建"></a>Stream 的创建</h3><h4 id="通过已有的数组来创建流"><a href="#通过已有的数组来创建流" class="headerlink" title="通过已有的数组来创建流"></a>通过已有的数组来创建流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = new String[] &#123;&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream = Arrays.stream(arr);</span><br></pre></td></tr></table></figure><h4 id="通过已有的集合来创建流"><a href="#通过已有的集合来创建流" class="headerlink" title="通过已有的集合来创建流"></a>通过已有的集合来创建流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;, &quot;Hello World&quot;, &quot;Hello Stream&quot;);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br></pre></td></tr></table></figure><h4 id="通过-Stream-创建流"><a href="#通过-Stream-创建流" class="headerlink" title="通过 Stream 创建流"></a>通过 Stream 创建流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;Hello&quot;, &quot;World&quot;, &quot;Hello World&quot;, &quot;Hello Stream&quot;);</span><br></pre></td></tr></table></figure><h3 id="Stream-中间操作"><a href="#Stream-中间操作" class="headerlink" title="Stream 中间操作"></a>Stream 中间操作</h3><p>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新 stream。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 用于通过设置的条件过滤出元素，以下代码使用 filter 方法过滤掉空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;Hello&quot;, &quot;&quot;, &quot;World&quot;, &quot;Hello World&quot;, &quot;Hello Stream&quot;);</span><br><span class="line">strings.stream().filter(s -&gt; !s.isEmpty()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">numbers.stream().map(i -&gt; i * i).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h4><p>limit/skip limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保留4个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">numbers.stream().limit(4).forEach(System.out::println);</span><br><span class="line">numbers.stream().skip(4).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted 用于对流进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>distinct 主要用来去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Stream-最终操作"><a href="#Stream-最终操作" class="headerlink" title="Stream 最终操作"></a>Stream 最终操作</h3><blockquote><p>最终操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以 pipeline 的方式执行，这样可以减少迭代次数。计算完成之后 stream 就会失效。</p></blockquote><p>最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常。</p><p>常用的最终操作如下：</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach 迭代流中的每个数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>count 用来统计流中的元素个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;Hello&quot;, &quot;Stream&quot;);</span><br><span class="line">System.out.println(strings.stream().count());</span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect 一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;, &quot;Hello Stream&quot;);</span><br><span class="line">strings = strings.stream().filter(s -&gt; s.startsWith(&quot;Hello&quot;)).collect(Collectors.toList());</span><br><span class="line">System.out.println(strings);</span><br></pre></td></tr></table></figure><h3 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h3><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>一些产生统计结果的收集器也非常有用。它们主要用于 int、double、long 等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul><li><a href="https://blog.csdn.net/chenhao_c_h/article/details/80691284" target="_blank" rel="noopener">https://blog.csdn.net/chenhao_c_h/article/details/80691284</a></li><li><a href="https://blog.csdn.net/papima/article/details/81808445" target="_blank" rel="noopener">https://blog.csdn.net/papima/article/details/81808445</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Stream&quot;&gt;&lt;a href=&quot;#什么是-Stream&quot; class=&quot;headerlink&quot; title=&quot;什么是 Stream&quot;&gt;&lt;/a&gt;什么是 Stream&lt;/h3&gt;&lt;p&gt;Stream（流）是一个来自数据源的元素队列并支持聚合操作。&lt;br&gt;在 Ja
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangshengjian.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zhangshengjian.github.io/tags/Java/"/>
    
      <category term="Stream" scheme="https://zhangshengjian.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 常见问题以及解决方案</title>
    <link href="https://zhangshengjian.github.io/2019/09/04/Oracle-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zhangshengjian.github.io/2019/09/04/Oracle-常见问题以及解决方案/</id>
    <published>2019-09-04T14:43:00.000Z</published>
    <updated>2019-09-04T14:55:48.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PL-SQL-Developer-使用相关问题"><a href="#PL-SQL-Developer-使用相关问题" class="headerlink" title="PL/SQL Developer 使用相关问题"></a>PL/SQL Developer 使用相关问题</h3><h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><p>点击如图所示中的锁，提示如下错误：</p><p><img src="/images/pasted-60.png" alt="图一"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>执行 SQL 语句的时候将 ROWID 也查出来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.*, A.ROWID FROM USER A WHERE A.USER_NAME = &apos;ZSJ&apos;;</span><br></pre></td></tr></table></figure><h3 id="Oracle-存储过程如何进行批量更新大数据量操作"><a href="#Oracle-存储过程如何进行批量更新大数据量操作" class="headerlink" title="Oracle 存储过程如何进行批量更新大数据量操作"></a>Oracle 存储过程如何进行批量更新大数据量操作</h3><h4 id="问题现象-1"><a href="#问题现象-1" class="headerlink" title="问题现象"></a>问题现象</h4><p>工作中偶尔会遇到写存储过程去进行批量更新大数据量的操作，经常某张表的数据会有几百万甚至上千万的情况，这个时候如何来实现尽可能短的时间内来完成对大批量数据的更新动作？</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用 bulk collect 与 forall 来进行存储过程的实现。</p><p>具体写法可参考如下网址：</p><ul><li><a href="https://blog.csdn.net/ITdevil/article/details/94582857" target="_blank" rel="noopener">https://blog.csdn.net/ITdevil/article/details/94582857</a></li><li><a href="https://www.iteye.com/blog/ears-1485116" target="_blank" rel="noopener">https://www.iteye.com/blog/ears-1485116</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PL-SQL-Developer-使用相关问题&quot;&gt;&lt;a href=&quot;#PL-SQL-Developer-使用相关问题&quot; class=&quot;headerlink&quot; title=&quot;PL/SQL Developer 使用相关问题&quot;&gt;&lt;/a&gt;PL/SQL Developer 
      
    
    </summary>
    
      <category term="Oracle" scheme="https://zhangshengjian.github.io/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://zhangshengjian.github.io/tags/Oracle/"/>
    
      <category term="PL/SQL Developer" scheme="https://zhangshengjian.github.io/tags/PL-SQL-Developer/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API 设计</title>
    <link href="https://zhangshengjian.github.io/2019/09/04/RESTful-API-%E8%AE%BE%E8%AE%A1/"/>
    <id>https://zhangshengjian.github.io/2019/09/04/RESTful-API-设计/</id>
    <published>2019-09-04T14:36:00.000Z</published>
    <updated>2019-09-04T14:39:08.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP 是目前互联网使用最多的协议，没有之一。但是作为 HTTP 协议创始人之一的 Roy Fielding 认为，过去十年，大家都在错误的使用 HTTP 协议。删除一个数据，路径往往是 delete/{id} , 更新一条数据，路径往往被定义为 update/{id}。Roy Fielding 提出了一种用于设计 Web 服务的架构方法，称为 REpresentational State Transfer（REST）。REST 的概念是将 API 结构分离为操作和资源。</p><p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。本文将重点介绍如何设计出易于理解和使用的 API。</p></blockquote><h3 id="URL-设计"><a href="#URL-设计" class="headerlink" title="URL 设计"></a>URL 设计</h3><h4 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词 + 宾语"></a>动词 + 宾语</h4><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是 “动词 + 宾语” 的结构。比如，<code>GET /articles</code> 这个命令，<code>/articles</code> 是宾语。</p><p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- GET：读取（Read）</span><br><span class="line">- POST：新建（Create）</span><br><span class="line">- PUT：更新（Update）</span><br><span class="line">- PATCH：更新（Update），通常是部分更新</span><br><span class="line">- DELETE：删除（Delete）</span><br></pre></td></tr></table></figure><p>根据 HTTP 规范，动词一律大写。</p><h4 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h4><p>有些客户端只能使用 <code>GET</code> 和 <code>POST</code> 这两种方法。服务器必须接受 <code>POST</code> 模拟其他三个方法（<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>）。这时，客户端发出的 HTTP 请求，要加上 <code>X-HTTP-Method-Override</code> 属性，告诉服务器应该使用哪一个动词，覆盖 <code>POST</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1</span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure><p>上面的代码中，X-HTTP-Method-Override 指定本次请求方式是 <code>PUT</code> 而不是 <code>POST</code>。</p><h4 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h4><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如 <code>/articles</code> 这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- /getAllCars</span><br><span class="line">- /createNewCar</span><br><span class="line">- /deleteAllRedCars</span><br></pre></td></tr></table></figure><h4 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h4><p>既然 URL 是名词，那么应该使用复数，还是单数？</p><p>这没有统一的规定，但是常见的操作是读取一个集合，比如 <code>GET /articles</code> （读取所有文章），这里明显应该是复数。</p><p>为了统一起见，建议都使用复数 URL，比如 <code>GET /articles/2</code>要好于 <code>GET /article/2</code>。</p><h4 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h4><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12/categories/2</span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p><p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /authors/12?categories=2</span><br></pre></td></tr></table></figure><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles/published</span><br></pre></td></tr></table></figure><p>查询字符串的写法明显更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles?published=true</span><br></pre></td></tr></table></figure><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="状态码必须精确"><a href="#状态码必须精确" class="headerlink" title="状态码必须精确"></a>状态码必须精确</h4><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 1xx：相关信息</span><br><span class="line">- 2xx：操作成功</span><br><span class="line">- 3xx：重定向</span><br><span class="line">- 4xx：客户端错误</span><br><span class="line">- 5xx：服务器错误</span><br></pre></td></tr></table></figure><p>这五大类总共包含 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">100多种 </a>状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><p>API 不需要 <code>1xx</code> 状态码，下面介绍其他四类状态码的精确含义。</p><h4 id="2xx-状态码"><a href="#2xx-状态码" class="headerlink" title="2xx 状态码"></a>2xx 状态码</h4><p><code>200</code> 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- GET: 200 OK</span><br><span class="line">- POST: 201 Created</span><br><span class="line">- PUT: 200 OK</span><br><span class="line">- PATCH: 200 OK</span><br><span class="line">- DELETE: 204 No Content</span><br></pre></td></tr></table></figure><p>上面代码中，<code>POST</code>返回 <code>201</code> 状态码，表示生成了新的资源； <code>DELETE</code> 返回 <code>204</code> 状态码，表示资源已经不存在。</p><p>此外， <code>202 Accepted</code> 状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;task&quot;: &#123;</span><br><span class="line">    &quot;href&quot;: &quot;/api/company/job-management/jobs/2130040&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;2130040&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3xx-状态码"><a href="#3xx-状态码" class="headerlink" title="3xx 状态码"></a>3xx 状态码</h4><p>API 用不到 <code>301</code> 状态码（永久重定向）和 <code>302</code> 状态码（暂时重定向， <code>307</code> 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 用到的 <code>3xx</code> 状态码，主要是 <code>303 See Other</code>，表示参考另一个 URL。它与 <code>302</code> 和 <code>307</code> 的含义一样，也是 “暂时重定向”，区别在于 <code>302</code> 和 <code>307</code> 用于 <code>GET</code> 请求，而 <code>303</code> 用于 <code>POST</code>、 <code>PUT</code> 和 <code>DELETE</code> 请求。收到 <code>303</code> 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Location: /api/orders/12345</span><br></pre></td></tr></table></figure><h4 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h4><p><code>4xx</code> 状态码表示客户端错误，主要有下面几种。</p><p><code>400 Bad Request</code>：服务器不理解客户端的请求，未做任何处理。</p><p><code>401 Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证。</p><p><code>403 Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限。</p><p><code>404 Not Found</code>：所请求的资源不存在，或不可用。</p><p><code>405 Method Not Allowed</code>：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p><p><code>410 Gone</code>：所请求的资源已从这个地址转移，不再可用。</p><p><code>415 Unsupported Media Type</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p><p><code>422 Unprocessable Entity</code> ：客户端上传的附件无法处理，导致请求失败。</p><p><code>429 Too Many Requests</code>：客户端的请求次数超过限额。</p><h4 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h4><p><code>5xx</code> 状态码表示服务端错误。</p><p>一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p><p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p><h3 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h3><h4 id="不要返回纯本文"><a href="#不要返回纯本文" class="headerlink" title="不要返回纯本文"></a>不要返回纯本文</h4><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 <code>Content-Type</code> 属性要设为 <code>application/json</code>。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的 <code>ACCEPT</code> 属性也要设成 <code>application/json</code>。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><h4 id="发生错误时，不要返回-200-状态码"><a href="#发生错误时，不要返回-200-状态码" class="headerlink" title="发生错误时，不要返回 200 状态码"></a>发生错误时，不要返回 200 状态码</h4><p>有一种不恰当的做法是，即使发生错误，也返回 <code>200</code> 状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，解析数据体以后，才能得知操作失败。</p><p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">     &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h4><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p><p>举例来说，GitHub 的 API 都在 <a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a> 这个域名。访问它，就可以得到其他 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;,</span><br><span class="line">  &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;,</span><br><span class="line">  &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;,</span><br><span class="line">  &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,</span><br><span class="line">  &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;In progress&quot;,</span><br><span class="line">   &quot;links&quot;: &#123;[</span><br><span class="line">    &#123; &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;: &quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125; ,</span><br><span class="line">    &#123; &quot;rel&quot;:&quot;edit&quot;, &quot;method&quot;: &quot;put&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul><li><a href="https://blog.florimondmanca.com/restful-api-design-13-best-practices-to-make-your-users-happy" target="_blank" rel="noopener">RESTful API Design: 13 Best Practices to Make Your Users Happy</a>, by Florimond Manca</li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">API design</a>, by MicroSoft Azure</li><li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></li><li><a href="https://blog.csdn.net/g6u8w7p06dco99fq3/article/details/82230152" target="_blank" rel="noopener">https://blog.csdn.net/g6u8w7p06dco99fq3/article/details/82230152</a></li><li><a href="https://my.oschina.net/u/2330859/blog/468829" target="_blank" rel="noopener">https://my.oschina.net/u/2330859/blog/468829</a></li><li><a href="https://www.cnblogs.com/artech/p/restful-web-api-01.html" target="_blank" rel="noopener">https://www.cnblogs.com/artech/p/restful-web-api-01.html</a></li><li><a href="https://www.cnblogs.com/artech/p/restful-web-api-02.html" target="_blank" rel="noopener">https://www.cnblogs.com/artech/p/restful-web-api-02.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;HTTP 是目前互联网使用最多的协议，没有之一。但是作为 HTTP 协议创始人之一的 Roy Fielding 认为，过去十年，大家都在错误的使用 HTTP 协议。删除一个数据，路径往往是 delete/{id} , 更新一条数据，路径往往被定义为
      
    
    </summary>
    
      <category term="RESTful" scheme="https://zhangshengjian.github.io/categories/RESTful/"/>
    
    
      <category term="RESTful" scheme="https://zhangshengjian.github.io/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 经典四表查询</title>
    <link href="https://zhangshengjian.github.io/2019/08/28/MySQL-%E7%BB%8F%E5%85%B8%E5%9B%9B%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>https://zhangshengjian.github.io/2019/08/28/MySQL-经典四表查询/</id>
    <published>2019-08-28T13:09:00.000Z</published>
    <updated>2019-09-04T14:34:57.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h4 id="创建学生表"><a href="#创建学生表" class="headerlink" title="创建学生表"></a>创建学生表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student</span><br><span class="line">(</span><br><span class="line">    sid VARCHAR(32),</span><br><span class="line">    sname VARCHAR(32), </span><br><span class="line">    sage INT, </span><br><span class="line">    ssex VARCHAR(8)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="创建课程表"><a href="#创建课程表" class="headerlink" title="创建课程表"></a>创建课程表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE course</span><br><span class="line">(</span><br><span class="line">    cid VARCHAR(32), </span><br><span class="line">    cname VARCHAR(32), </span><br><span class="line">    tid VARCHAR(32)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="创建学生课程分数表"><a href="#创建学生课程分数表" class="headerlink" title="创建学生课程分数表"></a>创建学生课程分数表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sc</span><br><span class="line">( </span><br><span class="line">    sid VARCHAR(32), </span><br><span class="line">    cid VARCHAR(32), </span><br><span class="line">    score INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="创建教师表"><a href="#创建教师表" class="headerlink" title="创建教师表"></a>创建教师表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE teacher</span><br><span class="line">( </span><br><span class="line">    tid VARCHAR(32), </span><br><span class="line">    tname VARCHAR(16) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="初始化表数据"><a href="#初始化表数据" class="headerlink" title="初始化表数据"></a>初始化表数据</h3><h4 id="初始化学生表数据"><a href="#初始化学生表数据" class="headerlink" title="初始化学生表数据"></a>初始化学生表数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into student </span><br><span class="line">select &apos;1&apos;, &apos;刘一&apos;, 18, &apos;男&apos;</span><br><span class="line">union all select &apos;2&apos;, &apos;钱二&apos;, 19, &apos;女&apos; </span><br><span class="line">union all select &apos;3&apos;, &apos;张三&apos;, 17, &apos;男&apos;</span><br><span class="line">union all select &apos;4&apos;, &apos;李四&apos;, 18, &apos;女&apos; </span><br><span class="line">union all select &apos;5&apos;, &apos;王五&apos;, 17, &apos;男&apos;</span><br><span class="line">union all select &apos;6&apos;, &apos;赵六&apos;, 19, &apos;女&apos;;</span><br></pre></td></tr></table></figure><h4 id="初始化教师表数据"><a href="#初始化教师表数据" class="headerlink" title="初始化教师表数据"></a>初始化教师表数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into teacher</span><br><span class="line">select 1, &apos;叶平&apos;</span><br><span class="line">union all select 2, &apos;贺高&apos;</span><br><span class="line">union all select 3, &apos;杨艳&apos;</span><br><span class="line">union all select 4, &apos;周磊&apos;;</span><br></pre></td></tr></table></figure><h4 id="初始化课程表数据"><a href="#初始化课程表数据" class="headerlink" title="初始化课程表数据"></a>初始化课程表数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into course</span><br><span class="line">select &apos;1&apos;, &apos;语文&apos;, &apos;1&apos;</span><br><span class="line">union all select &apos;2&apos;, &apos;数学&apos;, &apos;2&apos;</span><br><span class="line">union all select &apos;3&apos;, &apos;英语&apos;, &apos;3&apos;</span><br><span class="line">union all select &apos;4&apos;, &apos;物理&apos;, &apos;4&apos;;</span><br></pre></td></tr></table></figure><h4 id="初始化学生课程成绩表数据"><a href="#初始化学生课程成绩表数据" class="headerlink" title="初始化学生课程成绩表数据"></a>初始化学生课程成绩表数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">insert into sc </span><br><span class="line">select &apos;1&apos;, &apos;1&apos;, 56 </span><br><span class="line">union all select &apos;1&apos;, &apos;2&apos;, 78</span><br><span class="line">union all select &apos;1&apos;, &apos;3&apos;, 67</span><br><span class="line">union all select &apos;1&apos;, &apos;4&apos;, 58</span><br><span class="line">union all select &apos;2&apos;, &apos;1&apos;, 79</span><br><span class="line">union all select &apos;2&apos;, &apos;2&apos;, 81</span><br><span class="line">union all select &apos;2&apos;, &apos;3&apos;, 92</span><br><span class="line">union all select &apos;2&apos;, &apos;4&apos;, 68</span><br><span class="line">union all select &apos;3&apos;, &apos;1&apos;, 91</span><br><span class="line">union all select &apos;3&apos;, &apos;2&apos;, 47</span><br><span class="line">union all select &apos;3&apos;, &apos;3&apos;, 88</span><br><span class="line">union all select &apos;3&apos;, &apos;4&apos;, 56</span><br><span class="line">union all select &apos;4&apos;, &apos;2&apos;, 88</span><br><span class="line">union all select &apos;4&apos;, &apos;3&apos;, 90</span><br><span class="line">union all select &apos;4&apos;, &apos;4&apos;, 93</span><br><span class="line">union all select &apos;5&apos;, &apos;1&apos;, 46</span><br><span class="line">union all select &apos;5&apos;, &apos;3&apos;, 78</span><br><span class="line">union all select &apos;5&apos;, &apos;4&apos;, 53</span><br><span class="line">union all select &apos;6&apos;, &apos;1&apos;, 35</span><br><span class="line">union all select &apos;6&apos;, &apos;2&apos;, 68</span><br><span class="line">union all select &apos;6&apos;, &apos;4&apos;, 71;</span><br></pre></td></tr></table></figure><h3 id="SQL-查询问题"><a href="#SQL-查询问题" class="headerlink" title="SQL 查询问题"></a>SQL 查询问题</h3><h4 id="查询-“1”-课程比-“2”-课程成绩高的所有学生的学号"><a href="#查询-“1”-课程比-“2”-课程成绩高的所有学生的学号" class="headerlink" title="查询 “1” 课程比 “2” 课程成绩高的所有学生的学号"></a>查询 “1” 课程比 “2” 课程成绩高的所有学生的学号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.sid from (select sid,score from sc where cid = &apos;1&apos;) a, (select sid,score from sc where cid = &apos;2&apos;) b where a.score &gt; b.score and a.sid = b.sid;</span><br></pre></td></tr></table></figure><h4 id="查询平均成绩大于-60-分的同学的学号和平均成绩"><a href="#查询平均成绩大于-60-分的同学的学号和平均成绩" class="headerlink" title="查询平均成绩大于 60 分的同学的学号和平均成绩"></a>查询平均成绩大于 60 分的同学的学号和平均成绩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sid, avg(score) from sc group by sid having avg(score) &gt;  60;</span><br></pre></td></tr></table></figure><h4 id="查询所有同学的学号、姓名、选课数、总成绩"><a href="#查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="查询所有同学的学号、姓名、选课数、总成绩"></a>查询所有同学的学号、姓名、选课数、总成绩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select s.sid,s.sname,count(sc.cid),sum(sc.score) from student s,sc sc where s.sid = sc.sid group by sid;</span><br><span class="line"></span><br><span class="line">select s.sid,s.sname,count(sc.cid),sum(sc.score) from student s left outer join sc on s.sid=sc.sid group by s.sid,sname;</span><br></pre></td></tr></table></figure><h4 id="查询姓-“李”-的老师的个数"><a href="#查询姓-“李”-的老师的个数" class="headerlink" title="查询姓 “李” 的老师的个数"></a>查询姓 “李” 的老师的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(tid) from teacher where tname like &apos;李%&apos;;</span><br><span class="line"></span><br><span class="line">select count(distinct(tname)) from teacher where tname like &apos;李%&apos;;</span><br></pre></td></tr></table></figure><h4 id="查询没学过-“叶平”-老师课的同学的学号、姓名"><a href="#查询没学过-“叶平”-老师课的同学的学号、姓名" class="headerlink" title="查询没学过 “叶平” 老师课的同学的学号、姓名"></a>查询没学过 “叶平” 老师课的同学的学号、姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.sid, s.sname from student s where s.sid not in (select distinct(sc.sid) from sc, course c, teacher t where sc.cid = c.cid and t.tid = c.tid and t.tname = &quot;叶平&quot;);</span><br></pre></td></tr></table></figure><h4 id="查询学过-“1”-并且也学过编号-“2”-课程的同学的学号、姓名"><a href="#查询学过-“1”-并且也学过编号-“2”-课程的同学的学号、姓名" class="headerlink" title="查询学过 “1” 并且也学过编号 “2” 课程的同学的学号、姓名"></a>查询学过 “1” 并且也学过编号 “2” 课程的同学的学号、姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sid, sname from student where sid in (select sid from sc where cid = &apos;2&apos; and sid in (select sid from sc where cid = &apos;1&apos;));</span><br><span class="line"></span><br><span class="line">select s.sid, s.sname from student s, sc where s.sid = sc.sid and sc.cid = &apos;1&apos; and exists (select * from sc as sc_2 where sc_2.sid = sc.sid and sc_2.cid = &apos;2&apos;);</span><br></pre></td></tr></table></figure><h4 id="查询学过-“叶平”-老师所教的所有课的同学的学号、姓名"><a href="#查询学过-“叶平”-老师所教的所有课的同学的学号、姓名" class="headerlink" title="查询学过 “叶平” 老师所教的所有课的同学的学号、姓名"></a>查询学过 “叶平” 老师所教的所有课的同学的学号、姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sid, sname from student</span><br><span class="line">where sid in (select sid from sc, course, teacher where sc.cid = course.cid and teacher.tid = course.tid and teacher.tname = &apos;叶平&apos;</span><br><span class="line">group by sid having count(sc.cid) = (select count(course.cid) from course, teacher where course.tid = teacher.tid and teacher.tname = &apos;叶平&apos;));</span><br></pre></td></tr></table></figure><h4 id="查询所有课程成绩小于-60-分的同学的学号、姓名"><a href="#查询所有课程成绩小于-60-分的同学的学号、姓名" class="headerlink" title="查询所有课程成绩小于 60 分的同学的学号、姓名"></a>查询所有课程成绩小于 60 分的同学的学号、姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct(s.sid), s.sname from sc, student s where sc.sid = s.sid and sc.score &lt; 60;</span><br></pre></td></tr></table></figure><h4 id="查询没有学全所有课的同学的学号、姓名"><a href="#查询没有学全所有课的同学的学号、姓名" class="headerlink" title="查询没有学全所有课的同学的学号、姓名"></a>查询没有学全所有课的同学的学号、姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.sid, s.sname from student s,sc where s.sid = sc.sid group by s.sid, s.sname having count(sc.cid) &lt; (select count(cid) from course);</span><br></pre></td></tr></table></figure><h4 id="查询至少有一门课与学号为-“1”-的同学所学相同的同学的学号和姓名"><a href="#查询至少有一门课与学号为-“1”-的同学所学相同的同学的学号和姓名" class="headerlink" title="查询至少有一门课与学号为 “1” 的同学所学相同的同学的学号和姓名"></a>查询至少有一门课与学号为 “1” 的同学所学相同的同学的学号和姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct(s.sid), s.sname from student s, sc where s.sid = sc.sid and sc.cid in (select cid from sc where sc.sid = &apos;1&apos;);</span><br></pre></td></tr></table></figure><h4 id="查询至少学过学号为-“1”-同学所有一门课的其他同学学号和姓名"><a href="#查询至少学过学号为-“1”-同学所有一门课的其他同学学号和姓名" class="headerlink" title="查询至少学过学号为 “1” 同学所有一门课的其他同学学号和姓名"></a>查询至少学过学号为 “1” 同学所有一门课的其他同学学号和姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct s.sid, s.sname from student s, sc where s.sid = sc.sid and s.sid != &apos;1&apos; and sc.cid in (select cid from sc where sc.sid = &apos;1&apos;);</span><br></pre></td></tr></table></figure><h4 id="删除学习-“叶平”-老师课的-SC-表记录"><a href="#删除学习-“叶平”-老师课的-SC-表记录" class="headerlink" title="删除学习 “叶平” 老师课的 SC 表记录"></a>删除学习 “叶平” 老师课的 SC 表记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from sc where cid in (select distinct(cid) from (select sc.cid from sc, course c, teacher t where sc.cid = c.cid and c.tid = t.tid and t.tname = &apos;叶平&apos;) a);</span><br></pre></td></tr></table></figure><h4 id="向-SC-表中插入一些记录，这些记录要求符合以下条件：1、没有上过编号-“2”-课程的同学学号；2、插入-“2”-号课程的平均成绩"><a href="#向-SC-表中插入一些记录，这些记录要求符合以下条件：1、没有上过编号-“2”-课程的同学学号；2、插入-“2”-号课程的平均成绩" class="headerlink" title="向 SC 表中插入一些记录，这些记录要求符合以下条件：1、没有上过编号 “2” 课程的同学学号；2、插入 “2” 号课程的平均成绩"></a>向 SC 表中插入一些记录，这些记录要求符合以下条件：1、没有上过编号 “2” 课程的同学学号；2、插入 “2” 号课程的平均成绩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into sc (select sid, &apos;2&apos;, (select avg(score) from sc where cid = &apos;2&apos;) from student where sid not in (select sid from sc where cid = &apos;2&apos;));</span><br></pre></td></tr></table></figure><h4 id="查询和-“2”-号的同学学习的课程完全相同的其他同学学号和姓名"><a href="#查询和-“2”-号的同学学习的课程完全相同的其他同学学号和姓名" class="headerlink" title="查询和 “2” 号的同学学习的课程完全相同的其他同学学号和姓名"></a>查询和 “2” 号的同学学习的课程完全相同的其他同学学号和姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sid, sname from student where sid in (select sid from sc where cid in (select cid from sc where sid = &apos;2&apos;) group by sid having count(*) = (select count(*) from sc where sid = &apos;2&apos;));</span><br></pre></td></tr></table></figure><h4 id="把-“SC”-表中-“叶平”-老师教的课的成绩都更改为此课程的平均成绩"><a href="#把-“SC”-表中-“叶平”-老师教的课的成绩都更改为此课程的平均成绩" class="headerlink" title="把 “SC” 表中 “叶平” 老师教的课的成绩都更改为此课程的平均成绩"></a>把 “SC” 表中 “叶平” 老师教的课的成绩都更改为此课程的平均成绩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update sc set score = (select a from (select avg(sc_2.score) a from sc sc_2 where sc_2.cid = sc.cid) x) where sc.cid in (select course.cid from course, teacher where course.tid = teacher.tid and teacher.tname = &apos;叶平&apos;);</span><br></pre></td></tr></table></figure><h4 id="按平均成绩从高到低显示所有学生的-“语文”、”数学”、”英语”-三门的课程成绩，按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分"><a href="#按平均成绩从高到低显示所有学生的-“语文”、”数学”、”英语”-三门的课程成绩，按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分" class="headerlink" title="按平均成绩从高到低显示所有学生的 “语文”、”数学”、”英语” 三门的课程成绩，按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分"></a>按平均成绩从高到低显示所有学生的 “语文”、”数学”、”英语” 三门的课程成绩，按如下形式显示：学生ID，语文，数学，英语，有效课程数，有效平均分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sid as 学生ID,(select score from sc where sc.sid = t.sid and cid = &apos;1&apos;) as 语文,(select score from sc where sc.sid = t.sid and cid = &apos;2&apos;) as 数学,(select score from sc where sc.sid = t.sid and cid = &apos;3&apos;) as 英语,count(*) as 有效课程数, avg(t.score) as 有效平均成绩 from sc as tgroup by sid order by avg(t.score);</span><br></pre></td></tr></table></figure><h4 id="查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"><a href="#查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分" class="headerlink" title="查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"></a>查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cid as 课程ID, max(score) as 最高分, min(score) as 最低分 from sc group by cid;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h3&gt;&lt;h4 id=&quot;创建学生表&quot;&gt;&lt;a href=&quot;#创建学生表&quot; class=&quot;headerlink&quot; title=&quot;创建学生表&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://zhangshengjian.github.io/tags/MySQL/"/>
    
      <category term="SQL" scheme="https://zhangshengjian.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Java setDaemon(true)</title>
    <link href="https://zhangshengjian.github.io/2019/08/22/Java-setDaemon-true/"/>
    <id>https://zhangshengjian.github.io/2019/08/22/Java-setDaemon-true/</id>
    <published>2019-08-21T23:36:00.000Z</published>
    <updated>2019-08-22T00:14:33.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在代码中遇到过 setDaemon(true)，但是一直没弄清楚该方法是做什么的，现在研究一波这东西到底是做什么的。</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>守护线程，也称”服务线程”，在没有用户线程可服务时会自动离开。</p><p>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</p><p>设置：通过 <code>setDaemon(true)</code> 来设置线程为”守护线程”；将一个用户线程设置为守护线程的方式是在 <strong>线程对象创建</strong> 之前用线程对象的 <code>setDaemon</code> 方法。</p><h3 id="守护线程例子"><a href="#守护线程例子" class="headerlink" title="守护线程例子"></a>守护线程例子</h3><p>垃圾回收线程就是一个经典的守护线程，当程序中不再有任何运行的 Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统”同生共死”。那 Java 的守护线程是什么样子的呢。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</p><h3 id="例子程序"><a href="#例子程序" class="headerlink" title="例子程序"></a>例子程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread = new Thread(this);</span><br><span class="line"></span><br><span class="line">thread.setDaemon(true);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>当 Java 虚拟机中没有非守护线程在运行的时候，Java 虚拟机会关闭。当所有常规线程运行完毕以后，守护线程不管运行到哪里，虚拟机都会退出运行。所以守护线程最好不要写一些会影响程序的业务逻辑。否则无法预料程序到底会出现什么问题。</p><h3 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;sleep 1s&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 默认为false,设置为false代表非守护线程,true为守护线程,守护线程在主方法结束时候结束</span><br><span class="line">//        thread.setDaemon(true);</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main thread is over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">main thread is over</span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br></pre></td></tr></table></figure><p>thread.setDaemon(true)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 1s</span><br><span class="line">sleep 1s</span><br><span class="line">main thread is over</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在代码中遇到过 setDaemon(true)，但是一直没弄清楚该方法是做什么的，现在研究一波这东西到底是做什么的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangshengjian.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://zhangshengjian.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://zhangshengjian.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://zhangshengjian.github.io/2019/08/12/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://zhangshengjian.github.io/2019/08/12/学习计划/</id>
    <published>2019-08-12T13:25:00.000Z</published>
    <updated>2019-09-20T15:06:37.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019-09-20-2019-09-30"><a href="#2019-09-20-2019-09-30" class="headerlink" title="2019/09/20 - 2019/09/30"></a>2019/09/20 - 2019/09/30</h3><ul><li>VUE 入门学习</li></ul><h3 id="待排计划"><a href="#待排计划" class="headerlink" title="待排计划"></a>待排计划</h3><ul><li>SQL 能力（group by、join、left join、right join 等）</li><li>阶段性的总结</li><li>沟通能力</li><li>MyBatis plus</li><li>SpringBoot</li><li>SpringCloud</li><li>Zookeeper</li><li>Dubbo</li><li>VUE</li><li>Element UI</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2019-09-20-2019-09-30&quot;&gt;&lt;a href=&quot;#2019-09-20-2019-09-30&quot; class=&quot;headerlink&quot; title=&quot;2019/09/20 - 2019/09/30&quot;&gt;&lt;/a&gt;2019/09/20 - 2019/09/
      
    
    </summary>
    
      <category term="Other" scheme="https://zhangshengjian.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="https://zhangshengjian.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>心灵鸡汤</title>
    <link href="https://zhangshengjian.github.io/2019/08/12/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/"/>
    <id>https://zhangshengjian.github.io/2019/08/12/心灵鸡汤/</id>
    <published>2019-08-12T13:22:00.000Z</published>
    <updated>2019-08-21T23:30:21.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="团队篇"><a href="#团队篇" class="headerlink" title="团队篇"></a>团队篇</h3><p>作为一个领导人，应该控制自己的情绪，很多时候发脾气是无能的表现，合理的情绪控制对于团队的和谐，稳定军心有大作用。 - 马云</p><h3 id="励志篇"><a href="#励志篇" class="headerlink" title="励志篇"></a>励志篇</h3><p>短暂的激情是不值钱的，只有持久的激情才是赚钱的。 - 马云</p><h3 id="实干篇"><a href="#实干篇" class="headerlink" title="实干篇"></a>实干篇</h3><p>我喜欢程序员，他们单纯、固执、容易体会到成就感；面对压力，能够挑灯夜战不眠不休；面对困难，能够迎难而上挑战自我。</p><p>对于大部分壁垒不高的专业，在大学里学的和工作中实际用到的，差距很大。而企业看重的是应届生的学习能力，真不是你读过某个专业4年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;团队篇&quot;&gt;&lt;a href=&quot;#团队篇&quot; class=&quot;headerlink&quot; title=&quot;团队篇&quot;&gt;&lt;/a&gt;团队篇&lt;/h3&gt;&lt;p&gt;作为一个领导人，应该控制自己的情绪，很多时候发脾气是无能的表现，合理的情绪控制对于团队的和谐，稳定军心有大作用。 - 马云&lt;/p&gt;

      
    
    </summary>
    
      <category term="Other" scheme="https://zhangshengjian.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="https://zhangshengjian.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>技术 概念篇</title>
    <link href="https://zhangshengjian.github.io/2019/08/12/%E6%8A%80%E6%9C%AF-%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>https://zhangshengjian.github.io/2019/08/12/技术-概念篇/</id>
    <published>2019-08-12T13:10:00.000Z</published>
    <updated>2019-08-28T14:17:26.719Z</updated>
    
    <content type="html"><![CDATA[<p>技术视野的拓展，收藏一波阅读过的好的技术文章～～～</p><p><a href="https://blog.csdn.net/weixin_43167418/article/details/98564755" target="_blank" rel="noopener"><u>CDN<u></u></u></a></p><p><a href="https://blog.csdn.net/qiuzhongweiwei/article/details/80172529" target="_blank" rel="noopener"><u>网关<u></u></u></a></p><p><a href="https://blog.csdn.net/baron_leizhang/article/details/99675933" target="_blank" rel="noopener"><u>如何写邮件<u></u></u></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;技术视野的拓展，收藏一波阅读过的好的技术文章～～～&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43167418/article/details/98564755&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="Other" scheme="https://zhangshengjian.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="https://zhangshengjian.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Demo</title>
    <link href="https://zhangshengjian.github.io/2019/08/04/Elasticsearch-Demo/"/>
    <id>https://zhangshengjian.github.io/2019/08/04/Elasticsearch-Demo/</id>
    <published>2019-08-04T13:32:00.000Z</published>
    <updated>2019-08-04T13:49:27.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h3><blockquote><p>Spring Data Elasticsearch 是 Spring 提供的一种以 Spring Data 风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p></blockquote><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p><strong>@Document</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 标示映射到 Elasticsearch 文档上的领域对象</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">// 索引库名次，mysql 中数据库的概念</span><br><span class="line">    String indexName();</span><br><span class="line">    // 文档类型，mysql 中表的概念</span><br><span class="line">    String type() default &quot;&quot;;</span><br><span class="line">    // 默认分片数</span><br><span class="line">    short shards() default 5;</span><br><span class="line">    // 默认副本数量</span><br><span class="line">    short replicas() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@Id</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 表示是文档的 id，文档可以认为是 mysql 中表行的概念</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@Field</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public @interface Field &#123;</span><br><span class="line">// 文档中字段的类型</span><br><span class="line">FieldType type() default FieldType.Auto;</span><br><span class="line">// 是否建立倒排索引</span><br><span class="line">boolean index() default true;</span><br><span class="line">// 是否进行存储</span><br><span class="line">boolean store() default false;</span><br><span class="line">// 分词器名次</span><br><span class="line">String analyzer() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为文档自动指定元数据类型</span><br><span class="line">public enum FieldType &#123;</span><br><span class="line">Text, // 会进行分词并建了索引的字符类型</span><br><span class="line">Integer,</span><br><span class="line">Long,</span><br><span class="line">Date,</span><br><span class="line">Float,</span><br><span class="line">Double,</span><br><span class="line">Boolean,</span><br><span class="line">Object,</span><br><span class="line">Auto, // 自动判断字段类型</span><br><span class="line">Nested, // 嵌套对象类型</span><br><span class="line">Ip,</span><br><span class="line">Attachment, </span><br><span class="line">Keyword // 不会进行分词建立索引的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-Data-Elasticsearch&quot;&gt;&lt;a href=&quot;#Spring-Data-Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;Spring Data Elasticsearch&quot;&gt;&lt;/a&gt;Spring Data
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://zhangshengjian.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://zhangshengjian.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://zhangshengjian.github.io/2019/08/04/Elasticsearch/"/>
    <id>https://zhangshengjian.github.io/2019/08/04/Elasticsearch/</id>
    <published>2019-08-04T08:34:00.000Z</published>
    <updated>2019-08-04T13:33:59.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><blockquote><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，可用于实现全文搜索和实时数据统计。</p></blockquote><h3 id="Elasticsearch-的安装和使用"><a href="#Elasticsearch-的安装和使用" class="headerlink" title="Elasticsearch 的安装和使用"></a>Elasticsearch 的安装和使用</h3><p>1.下载 Elasticsearch6.2.2 的 zip 包，并解压到指定目录，下载地址：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2</a></p><p><img src="/images/pasted-41.png" alt="图一"></p><p>2.安装中文分词插件，将分词插件解压到 elasticsearch-6.2.2\plugins 下，分词插件下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip</a></p><p><img src="/images/pasted-42.png" alt="图二"></p><p>3.启动 Elasticsearch，在 elasticsearch-6-2-2 目录下执行命令 <code>bin/elasticsearch</code></p><p><img src="/images/pasted-43.png" alt="图三"></p><p>4.下载 Kibana，作为访问 Elasticsearch 的客户端，下载6.2.2版本的 zip 包，并解压到指定目录，下载地址：<a href="https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-darwin-x86_64.tar.gz" target="_blank" rel="noopener">https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-darwin-x86_64.tar.gz</a></p><p><img src="/images/pasted-44.png" alt="图四"></p><p>5.运行 bin 目录下的 bin/kibana，启动 Kibana 的用户界面</p><p><img src="/images/pasted-45.png" alt="图五"></p><p>6.访问 <a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a> 即可打开 Kibana 的用户界面</p><p><img src="/images/pasted-46.png" alt="图六"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Elasticsearch&quot;&gt;&lt;a href=&quot;#Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch&quot;&gt;&lt;/a&gt;Elasticsearch&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Elasticsearch
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://zhangshengjian.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://zhangshengjian.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>mall 电商系统学习</title>
    <link href="https://zhangshengjian.github.io/2019/08/01/mall-%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhangshengjian.github.io/2019/08/01/mall-电商系统学习/</id>
    <published>2019-08-01T14:28:28.000Z</published>
    <updated>2019-08-01T14:35:14.492Z</updated>
    
    <content type="html"><![CDATA[<h4 id="订单模块数据库表解析（一）"><a href="#订单模块数据库表解析（一）" class="headerlink" title="订单模块数据库表解析（一）"></a><a href="https://mp.weixin.qq.com/s/OcZQpT3b9YjR8xAZHblHAw" target="_blank" rel="noopener">订单模块数据库表解析（一）</a></h4><p>oms_order 订单表<br>oms_order_item 订单商品信息表<br>oms_order_operator_history 订单操作记录表<br>oms_order_setting 订单设置表</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;订单模块数据库表解析（一）&quot;&gt;&lt;a href=&quot;#订单模块数据库表解析（一）&quot; class=&quot;headerlink&quot; title=&quot;订单模块数据库表解析（一）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OcZQpT3b9Yj
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Intellij IDEA</title>
    <link href="https://zhangshengjian.github.io/2019/07/23/Intellij-IDEA/"/>
    <id>https://zhangshengjian.github.io/2019/07/23/Intellij-IDEA/</id>
    <published>2019-07-23T14:43:00.000Z</published>
    <updated>2019-09-23T11:02:39.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Intellij-IDEA-快捷键"><a href="#Intellij-IDEA-快捷键" class="headerlink" title="Intellij IDEA 快捷键"></a>Intellij IDEA 快捷键</h3><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + shift + enter</td><td>代码末尾加分号</td></tr></tbody></table><table><thead><tr><th>代码自动生成</th><th>描述</th></tr></thead><tbody><tr><td>psvm</td><td>main 函数</td></tr><tr><td>fori</td><td>for 循环</td></tr><tr><td>foreach</td><td>foreach 循环</td></tr></tbody></table><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><h4 id="设置界面风格及修改外部-UI-尺寸大小"><a href="#设置界面风格及修改外部-UI-尺寸大小" class="headerlink" title="设置界面风格及修改外部 UI 尺寸大小"></a>设置界面风格及修改外部 UI 尺寸大小</h4><p><img src="/images/pasted-47.png" alt="图一"></p><h4 id="打开-IDEA-时设置不重新打开最近的项目"><a href="#打开-IDEA-时设置不重新打开最近的项目" class="headerlink" title="打开 IDEA 时设置不重新打开最近的项目"></a>打开 IDEA 时设置不重新打开最近的项目</h4><blockquote><p>IDEA 默认会打开最近的项目，有时候我们需要自己选择要打开的项目，不勾选该选项可以实现。</p></blockquote><p><img src="/images/pasted-48.png" alt="图二"></p><h4 id="设置-IDEA-的快捷键"><a href="#设置-IDEA-的快捷键" class="headerlink" title="设置 IDEA 的快捷键"></a>设置 IDEA 的快捷键</h4><p><img src="/images/pasted-49.png" alt="图三"></p><h4 id="设置代码字体大小"><a href="#设置代码字体大小" class="headerlink" title="设置代码字体大小"></a>设置代码字体大小</h4><p><img src="/images/pasted-50.png" alt="图四"></p><h4 id="设置项目文件编码格式"><a href="#设置项目文件编码格式" class="headerlink" title="设置项目文件编码格式"></a>设置项目文件编码格式</h4><p><img src="/images/pasted-51.png" alt="图五"></p><h4 id="设置代码提示的匹配模式"><a href="#设置代码提示的匹配模式" class="headerlink" title="设置代码提示的匹配模式"></a>设置代码提示的匹配模式</h4><p><img src="/images/pasted-52.png" alt="图六"></p><h4 id="设置新建类文件的类注释模版"><a href="#设置新建类文件的类注释模版" class="headerlink" title="设置新建类文件的类注释模版"></a>设置新建类文件的类注释模版</h4><p><img src="/images/pasted-53.png" alt="图七"></p><h4 id="设置过滤显示文件"><a href="#设置过滤显示文件" class="headerlink" title="设置过滤显示文件"></a>设置过滤显示文件</h4><p><img src="/images/pasted-61.png" alt="图八"></p><h4 id="设置-properties-文件-unicode-码变成中文"><a href="#设置-properties-文件-unicode-码变成中文" class="headerlink" title="设置 properties 文件 unicode 码变成中文"></a>设置 properties 文件 unicode 码变成中文</h4><p><img src="/images/pasted-63.png" alt="图九"></p><h3 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h3><h4 id="Free-MyBatis-plugin"><a href="#Free-MyBatis-plugin" class="headerlink" title="Free MyBatis plugin"></a>Free MyBatis plugin</h4><blockquote><p>非常好用的 MyBatis 插件，对 MyBatis 的 xml 具有强大的提示功能，同时可以关联 mapper 接口和 mapper.xml 中的 sql 实现。</p></blockquote><p><img src="/images/pasted-54.png" alt="图十"></p><p>可以从 mapper 接口和 mapper.xml 文件中相互跳转</p><p><img src="/images/pasted-55.png" alt="图十一"></p><p>mapper.xml 中的各种提示</p><p><img src="/images/pasted-56.png" alt="图二"></p><h4 id="Lombok-plugin"><a href="#Lombok-plugin" class="headerlink" title="Lombok plugin"></a>Lombok plugin</h4><blockquote><p>Lombok 为 Java 语言添加了非常有趣的附加功能，你可以不用再为实体类手写 getter,setter 等方法，通过一个注解即可拥有。</p></blockquote><p><img src="/images/pasted-57.png" alt="图十三"></p><p>一个没有 getter,setter 方法的类通过添加 <code>@Getter</code> 和 <code>@Setter</code> 注解拥有了 getter,setter 方法。</p><p><img src="/images/pasted-58.png" alt="图十四"></p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h4 id="Command-line-is-too-long-Shorten-command-line-for"><a href="#Command-line-is-too-long-Shorten-command-line-for" class="headerlink" title="Command line is too long. Shorten command line for"></a>Command line is too long. Shorten command line for</h4><p><img src="/images/pasted-65.png" alt></p><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改项目下 .idea\workspace.xml，找到标签 &lt;component name=&quot;PropertiesComponent&quot;&gt; ，</span><br><span class="line">在标签里加一行  &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Intellij-IDEA-快捷键&quot;&gt;&lt;a href=&quot;#Intellij-IDEA-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Intellij IDEA 快捷键&quot;&gt;&lt;/a&gt;Intellij IDEA 快捷键&lt;/h3&gt;&lt;table&gt;
&lt;thea
      
    
    </summary>
    
      <category term="Tools" scheme="https://zhangshengjian.github.io/categories/Tools/"/>
    
    
      <category term="Intellij IDEA" scheme="https://zhangshengjian.github.io/tags/Intellij-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>JVM 运行参数的变量</title>
    <link href="https://zhangshengjian.github.io/2019/07/21/JVM-%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>https://zhangshengjian.github.io/2019/07/21/JVM-运行参数的变量/</id>
    <published>2019-07-21T15:09:00.000Z</published>
    <updated>2019-08-01T13:45:16.695Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>-server</td><td>一定要作为第一个参数，在多个 CPU 时性能佳</td></tr><tr><td>-Xms</td><td>初始堆内存大小（使用的最小内存）, CPU 性能高时此值应设的大一些</td></tr><tr><td>-Xmx</td><td>堆内存堆最大值，使用的最大堆内存</td></tr><tr><td>-XX:PermSize</td><td>设定内存的永久保存区域</td></tr><tr><td>-XX:MaxPermSize</td><td>设定最大内存的永久保存区域</td></tr><tr><td>-verbose:gc</td><td>垃圾收集时的信息打印</td></tr><tr><td>-XX:+printGC</td><td>垃圾收集时的信息打印</td></tr><tr><td>-Xloggc:../logs/gclog.log</td><td>指定 GC log 的位置，以文件输出</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印 GC 更详细的信息</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>输出 GC 的时间戳（以基准时间的形式）</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>在进行 GC 的前后打印出堆的信息</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>OOM 的时候，自动写 Heapdump 文件</td></tr><tr><td>-XX:HeapDumpPath</td><td>dump 文件位置</td></tr><tr><td>-Xmn</td><td>年轻代的堆内存大小，一般设置为 Xmx 的3、4分之一</td></tr></tbody></table><ul><li>-Xms 和 -Xmx 两个值是分配 JVM 的最小和最大内存，取决于硬件物理内存的大小，建议均设为物理内存的一半</li><li>-verbose:gc 在启动参数中加上 -verbose:gc 当发生 gc 时，可以打印出 gc 相关的信息；该信息不够高全面，等同于 -XX:+PrintGC。其实只要设置 -XX:+PrintGCDetails 就会自动带上 -verbose:gc和 -XX:+PrintGC</li></ul><blockquote><p>参考网址</p></blockquote><p><a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a><br><a href="https://mp.weixin.qq.com/s/8Y2GbVE2rKFTCq930WV-qg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8Y2GbVE2rKFTCq930WV-qg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数名称&lt;/th&gt;
&lt;th&gt;参数说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-server&lt;/td&gt;
&lt;td&gt;一定要作为第一个参数，在多个 CPU 时性能佳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
      <category term="JVM" scheme="https://zhangshengjian.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://zhangshengjian.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot - Web 综合开发</title>
    <link href="https://zhangshengjian.github.io/2019/07/19/Spring-Boot-Web-%E7%BB%BC%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>https://zhangshengjian.github.io/2019/07/19/Spring-Boot-Web-综合开发/</id>
    <published>2019-07-18T16:12:00.000Z</published>
    <updated>2019-07-19T06:32:42.301Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h4><p>Spring Boot Web 开发非常的简单，其中包括常用的 json 输出、filters、property、log 等</p><h5 id="json-接口开发"><a href="#json-接口开发" class="headerlink" title="json 接口开发"></a>json 接口开发</h5><p>在以前使用 Spring 开发项目，需要提供 json 接口时需要做哪些配置呢</p><blockquote><p>添加 jackjson 等相关 jar 包<br>配置 Spring Controller 扫描<br>对接的方法添加 @ResponseBody</p></blockquote><p>这样会经常由于配置错误，导致406错误等等，Spring Boot 如何做呢，只需要类添加<code>@RestController</code> 即可，默认类中的方法都会以 json 的格式返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(&quot;/getUser&quot;)</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">    User user=new User();</span><br><span class="line">    user.setUserName(&quot;小明&quot;);</span><br><span class="line">    user.setPassWord(&quot;xxxx&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要使用页面开发只要使用<code>@Controller</code>注解即可，下面会结合模板来说明</p><h4 id="自定义-Filter"><a href="#自定义-Filter" class="headerlink" title="自定义 Filter"></a>自定义 Filter</h4><p>我们常常在项目中会使用 filters 用于录调用日志、排除有 XSS 威胁的字符、执行权限验证等等。Spring Boot 自动添加了 OrderedCharacterEncodingFilter 和 HiddenHttpMethodFilter，并且我们可以自定义 Filter。</p><p>两个步骤：</p><blockquote><p>实现 Filter 接口，实现 Filter 方法<br>添加<code>@Configuration</code>注解，将自定义 Filter 加入过滤链</p></blockquote><h4 id="自定义-Property"><a href="#自定义-Property" class="headerlink" title="自定义 Property"></a>自定义 Property</h4><p>在 Web 开发的过程中，经常需要自定义一些配置文件，如何使用呢</p><p>配置在 application.properties 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.neo.title=纯洁的微笑</span><br><span class="line">com.neo.description=分享生活和技术</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Web-开发&quot;&gt;&lt;a href=&quot;#Web-开发&quot; class=&quot;headerlink&quot; title=&quot;Web 开发&quot;&gt;&lt;/a&gt;Web 开发&lt;/h4&gt;&lt;p&gt;Spring Boot Web 开发非常的简单，其中包括常用的 json 输出、filters、proper
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://zhangshengjian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://zhangshengjian.github.io/tags/Spring-Boot/"/>
    
      <category term="Web" scheme="https://zhangshengjian.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot - 入门篇</title>
    <link href="https://zhangshengjian.github.io/2019/07/18/Spring-Boot-%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>https://zhangshengjian.github.io/2019/07/18/Spring-Boot-入门篇/</id>
    <published>2019-07-18T09:11:00.000Z</published>
    <updated>2019-07-18T16:13:25.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Boot 火了这么久，面试任何一家公司已经成为 Java 程序员的必备技能，打算利用一个月时间细致学习一下 Spring Boot，给自己的技能包丰富一下技能储备。</p></blockquote><h3 id="Maven-构建项目"><a href="#Maven-构建项目" class="headerlink" title="Maven 构建项目"></a>Maven 构建项目</h3><p>通过 IDEA 构建项目</p><p><img src="/images/pasted-34.png" alt="step 1"><br><img src="/images/pasted-35.png" alt="step 2"><br><img src="/images/pasted-36.png" alt="step 3"><br><img src="/images/pasted-37.png" alt="step 4"><br><img src="/images/pasted-38.png" alt="step 5"><br><img src="/images/pasted-39.png" alt="step 6"></p><p>最后，启动 Application main 方法，至此一个 Java 项目搭建好了！</p><h3 id="引入-WEB-模块"><a href="#引入-WEB-模块" class="headerlink" title="引入 WEB 模块"></a>引入 WEB 模块</h3><p>1、pom.xml 中添加支持 web 的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>pom.xml 文件中默认有两个模块：</p><ul><li><code>spring-boot-starter</code> ：核心模块，包括自动配置支持、日志和 YAML，如果引入了 <code>spring-boot-starter-web</code> web 模块可以去掉此配置，因为 <code>spring-boot-starter-web</code> 自动依赖了 <code>spring-boot-starter</code>。</li><li><code>spring-boot-starter-test</code> ：测试模块，包括 JUnit、Hamcrest、Mockito。</li></ul><p>2、编写 Controller 内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>@RestController</code> 的意思就是 Controller 里面的方法都以 json 格式输出，不用再写什么 jackjson 配置的了！</p><p>3、启动主程序，打开浏览器访问 <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><h3 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h3><p>打开的<code>src/test/</code>下的测试入口，编写简单的 http 请求来测试；使用 mockmvc 进行，利用<code>MockMvcResultHandlers.print()</code>打印出执行结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class HelloTests &#123;</span><br><span class="line"></span><br><span class="line">   private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">   @Before</span><br><span class="line">   public void setUp() throws Exception &#123;</span><br><span class="line">       mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void getHello() throws Exception &#123;</span><br><span class="line">       mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(equalTo(&quot;Hello World&quot;)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="开发环境的调试"><a href="#开发环境的调试" class="headerlink" title="开发环境的调试"></a>开发环境的调试</h3><p>热启动在正常开发项目中已经很常见了吧，虽然平时开发 web 项目过程中，改动项目启重启总是报错；但SpringBoot 对调试支持很好，修改之后可以实时生效（经验证 IDEA 中每次修改完代码后需要手动 Build Project 才能生效），需要添加以下的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">      &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">            &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></p><p>该模块在完整的打包环境下运行的时候会被禁用。如果你使用<code>java -jar</code>启动应用或者用一个特定的 classloader 启动，它会认为这是一个“生产环境”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 Spring Boot 可以非常方便、快速搭建项目，不用关心框架之间的兼容性，适用版本等各种问题，使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring Boot 火了这么久，面试任何一家公司已经成为 Java 程序员的必备技能，打算利用一个月时间细致学习一下 Spring Boot，给自己的技能包丰富一下技能储备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Maven-构建
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://zhangshengjian.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://zhangshengjian.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>开发工具篇</title>
    <link href="https://zhangshengjian.github.io/2019/07/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>https://zhangshengjian.github.io/2019/07/18/开发工具篇/</id>
    <published>2019-07-18T01:27:00.000Z</published>
    <updated>2019-07-18T08:43:51.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开发工具篇</p></blockquote><table><thead><tr><th>工具</th><th>说明</th><th>官网</th></tr></thead><tbody><tr><td>IDEA</td><td>开发 IDE</td><td><a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download</a></td></tr><tr><td>RedisDesktop</td><td>redis 客户端连接工具</td><td><a href="https://redisdesktop.com/download" target="_blank" rel="noopener">https://redisdesktop.com/download</a></td></tr><tr><td>Robomongo</td><td>mongo 客户端连接工具</td><td><a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></td></tr><tr><td>SwitchHosts</td><td>本地 host 管理</td><td><a href="https://oldj.github.io/SwitchHosts/" target="_blank" rel="noopener">https://oldj.github.io/SwitchHosts/</a></td></tr><tr><td>X-shell</td><td>Linux 远程连接工具</td><td><a href="http://www.netsarang.com/download/software.html" target="_blank" rel="noopener">http://www.netsarang.com/download/software.html</a></td></tr><tr><td>SecureCRT</td><td>Linux 远程连接工具</td><td><a href="https://www.vandyke.com/products/securecrt/mac_osx.html" target="_blank" rel="noopener">https://www.vandyke.com/products/securecrt/mac_osx.html</a></td></tr><tr><td>Navicat</td><td>数据库连接工具</td><td><a href="http://www.formysql.com/xiazai.html" target="_blank" rel="noopener">http://www.formysql.com/xiazai.html</a></td></tr><tr><td>PowerDesigner</td><td>数据库设计工具</td><td><a href="http://powerdesigner.de/" target="_blank" rel="noopener">http://powerdesigner.de/</a></td></tr><tr><td>Axure</td><td>原型设计工具</td><td><a href="https://www.axure.com/" target="_blank" rel="noopener">https://www.axure.com/</a></td></tr><tr><td>MindMaster</td><td>思维导图设计工具</td><td><a href="http://www.edrawsoft.cn/mindmaster" target="_blank" rel="noopener">http://www.edrawsoft.cn/mindmaster</a></td></tr><tr><td>ScreenToGif</td><td>gif 录制工具</td><td><a href="https://www.screentogif.com/" target="_blank" rel="noopener">https://www.screentogif.com/</a></td></tr><tr><td>ProcessOn</td><td>流程图绘制工具</td><td><a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></td></tr><tr><td>PicPick</td><td>屏幕取色工具</td><td><a href="https://picpick.app/zh/" target="_blank" rel="noopener">https://picpick.app/zh/</a></td></tr><tr><td>Sublime Text</td><td>文本编辑器</td><td><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">http://www.sublimetext.com/</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开发工具篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;官网&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IDEA&lt;/td&gt;
&lt;
      
    
    </summary>
    
      <category term="Tools" scheme="https://zhangshengjian.github.io/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://zhangshengjian.github.io/tags/Tools/"/>
    
      <category term="开发工具" scheme="https://zhangshengjian.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Task</title>
    <link href="https://zhangshengjian.github.io/2019/07/17/Spring-Task/"/>
    <id>https://zhangshengjian.github.io/2019/07/17/Spring-Task/</id>
    <published>2019-07-17T07:59:00.000Z</published>
    <updated>2019-07-17T08:56:37.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring-Task-简介"><a href="#Spring-Task-简介" class="headerlink" title="Spring Task 简介"></a>Spring Task 简介</h4><blockquote><p>Spring Task 是 Spring 自主研发的轻量级定时任务工具，相比于 Quartz 更加简单方便，且不需要引入其他依赖即可使用。</p></blockquote><h4 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h4><blockquote><p>Cron 表达式是一个字符串，包括6~7个时间元素，在 Spring Task 中可以用于指定任务的执行时间。</p></blockquote><h5 id="Cron-的语法格式"><a href="#Cron-的语法格式" class="headerlink" title="Cron 的语法格式"></a>Cron 的语法格式</h5><p>Seconds Minutes Hours DayofMonth Month DayofWeek</p><h5 id="Cron-格式中每个时间元素的说明"><a href="#Cron-格式中每个时间元素的说明" class="headerlink" title="Cron 格式中每个时间元素的说明"></a>Cron 格式中每个时间元素的说明</h5><table><thead><tr><th>时间元素</th><th>可出现的字符</th><th>有效数值范围</th></tr></thead><tbody><tr><td>Seconds</td><td>, - * /</td><td>0-59</td></tr><tr><td>Minutes</td><td>, - * /</td><td>0-59</td></tr><tr><td>Hours</td><td>, - * /</td><td>0-23</td></tr><tr><td>DayofMonth</td><td>, - * / ? L W</td><td>0-31</td></tr><tr><td>Month</td><td>, - * /</td><td>1-12</td></tr><tr><td>DayofWeek</td><td>, - * / ? L #</td><td>1-7 或 SUN-SAT</td></tr></tbody></table><h5 id="Cron-格式中特殊字符说明"><a href="#Cron-格式中特殊字符说明" class="headerlink" title="Cron 格式中特殊字符说明"></a>Cron 格式中特殊字符说明</h5><table><thead><tr><th>字符</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>,</td><td>列出枚举值</td><td>0-59</td></tr><tr><td>-</td><td>表示触发范围</td><td>在 Minutes 域使用5-10，表示从5分到10分钟每分钟触发一次</td></tr><tr><td>*</td><td>匹配任意值</td><td>在 Minutes 域使用*, 表示每分钟都会触发一次</td></tr><tr><td>/</td><td>起始时间开始触发，每隔固定时间触发一次</td><td>在 Minutes 域使用5/10,表示5分时触发一次，每10分钟再触发一次</td></tr><tr><td>?</td><td>在 DayofMonth 和 DayofWeek 中，用于匹配任意值</td><td>在 DayofMonth 域使用?,表示每天都触发一次</td></tr><tr><td>#</td><td>在 DayofMonth 中，确定第几个星期几</td><td>1#3表示第三个星期日</td></tr><tr><td>L</td><td>表示最后</td><td>在 DayofWeek 中使用 5L,表示在最后一个星期四触发</td></tr><tr><td>W</td><td>表示有效工作日(周一到周五)</td><td>在 DayofMonth 使用 5W，如果5日是星期六，则将在最近的工作日4日触发一次</td></tr></tbody></table><h4 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h4><blockquote><p><a href="https://juejin.im/post/5cfa0ea16fb9a07eaf2b8261" target="_blank" rel="noopener">https://juejin.im/post/5cfa0ea16fb9a07eaf2b8261</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Spring-Task-简介&quot;&gt;&lt;a href=&quot;#Spring-Task-简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Task 简介&quot;&gt;&lt;/a&gt;Spring Task 简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Ta
      
    
    </summary>
    
      <category term="Spring" scheme="https://zhangshengjian.github.io/categories/Spring/"/>
    
    
      <category term="Spring Task" scheme="https://zhangshengjian.github.io/tags/Spring-Task/"/>
    
      <category term="Spring" scheme="https://zhangshengjian.github.io/tags/Spring/"/>
    
      <category term="定时服务" scheme="https://zhangshengjian.github.io/tags/%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
